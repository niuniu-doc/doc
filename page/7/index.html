<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.2">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="多数是学习笔记、偶尔发发感慨、给生活添加些许乐趣">
<meta property="og:type" content="website">
<meta property="og:title" content="牛牛的小窝">
<meta property="og:url" content="http://yoursite.com/page/7/index.html">
<meta property="og:site_name" content="牛牛的小窝">
<meta property="og:description" content="多数是学习笔记、偶尔发发感慨、给生活添加些许乐趣">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="niuniu">
<meta property="article:tag" content="Java, Mysql, Linux">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/page/7/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>牛牛的小窝</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">牛牛的小窝</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">不奢望岁月静好 只希望点滴积累</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/03/20/mysql_SQL%E6%89%A7%E8%A1%8C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="niuniu">
      <meta itemprop="description" content="多数是学习笔记、偶尔发发感慨、给生活添加些许乐趣">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="牛牛的小窝">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/20/mysql_SQL%E6%89%A7%E8%A1%8C/" class="post-title-link" itemprop="url">SQL执行</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-03-20 00:00:00" itemprop="dateCreated datePublished" datetime="2020-03-20T00:00:00+08:00">2020-03-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-05-07 11:31:06" itemprop="dateModified" datetime="2022-05-07T11:31:06+08:00">2022-05-07</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/MySQL/" itemprop="url" rel="index"><span itemprop="name">MySQL</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>[toc]</p>
<h3 id="SQL执行流程"><a href="#SQL执行流程" class="headerlink" title="SQL执行流程"></a>SQL执行流程</h3><h4 id="MySQL架构图"><a href="#MySQL架构图" class="headerlink" title="MySQL架构图"></a>MySQL架构图</h4><p><img src="https://upload-images.jianshu.io/upload_images/14027542-4270d2d72dee925f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/340" alt="image.png"></p>
<h4 id="server层、"><a href="#server层、" class="headerlink" title="server层、"></a>server层、</h4><blockquote>
<p>包含连接器、查询缓存、分析器、优化器、执行器等、涵盖mysql大部分核心功能、<br>及mysql所有的内置函数(日期、时间、数学和加密函数等)、所有跨存储引擎的功能<br>(视图、存储过程、触发器等)都在这一层实现</p>
</blockquote>
<h5 id="连接器"><a href="#连接器" class="headerlink" title="连接器"></a>连接器</h5><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mysql -h<span class="variable">$ip</span> -P<span class="variable">$port</span> -u<span class="variable">$user</span> -p</span><br><span class="line">若 用户名和密码 认证失败、会返回 Access denied <span class="keyword">for</span><span class="built_in"> user </span>的错误</span><br><span class="line">若认证通过、这个连接里的权限都会依赖此时权限表查到的权限</span><br><span class="line">此时用admin账号修改该用户的权限、不会立即生效、会在重新连接时生效</span><br><span class="line"></span><br><span class="line">连接完成后、无后续动作、则连接处于sleep状态、</span><br><span class="line"><span class="built_in"></span></span><br><span class="line"><span class="built_in">client </span>长时间(wait_time参数控制)不操作、连接器会断开连接</span><br><span class="line"></span><br><span class="line">连接断开之后、再发送请求、会收到 Lost<span class="built_in"> connection </span><span class="keyword">to</span> mysql<span class="built_in"> server </span>during query的响应</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="https://upload-images.jianshu.io/upload_images/14027542-60a2493de769f5b9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/14027542-18905125b398ebe6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/14027542-ee3accb459dc1246.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<h5 id="查询缓存"><a href="#查询缓存" class="headerlink" title="查询缓存"></a>查询缓存</h5><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">key</span> 是 sql、value是查询结果 - 任意更新会导致缓存失效</span><br><span class="line">不建议使用</span><br></pre></td></tr></table></figure>

<h5 id="分析器"><a href="#分析器" class="headerlink" title="分析器"></a>分析器</h5><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">词法分析: 根据关键词识别语句类型 <span class="keyword">select</span>/<span class="keyword">update</span>/<span class="keyword">insert</span></span><br><span class="line">语法分析: 若有语法错误、会返回 You have an error <span class="keyword">in</span> your <span class="keyword">SQL</span> </span><br><span class="line"></span><br><span class="line">elect <span class="number">1</span> <span class="keyword">from</span> t <span class="keyword">where</span> id=<span class="number">1</span>;</span><br><span class="line">ERROR <span class="number">1064</span> (<span class="number">42000</span>): You have an error <span class="keyword">in</span> your <span class="keyword">SQL</span> syntax; <span class="keyword">check</span> the manual that corresponds <span class="keyword">to</span> your MySQL <span class="keyword">server</span> <span class="keyword">version</span> <span class="keyword">for</span> the right syntax <span class="keyword">to</span> use near <span class="string">&#x27;elect 1 from t where id=1&#x27;</span> at <span class="type">line</span> <span class="number">1</span></span><br><span class="line">                         </span><br></pre></td></tr></table></figure>

<h5 id="优化器"><a href="#优化器" class="headerlink" title="优化器"></a>优化器</h5><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">经过分析器、mysql知道了想要做什么、优化器干什么呢 ？</span><br><span class="line"><span class="bullet">1.</span> 表中有多个索引的时候、决定使用哪个索引</span><br><span class="line"><span class="bullet">2.</span> 多表join的时候、决定连表顺序</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="https://upload-images.jianshu.io/upload_images/14027542-b2765ac683595a26.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<h5 id="执行器"><a href="#执行器" class="headerlink" title="执行器"></a>执行器</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">在分析器、优化器之后、mysql知道了要做什么、怎么做、就开始进入到执行器阶段、开始执行</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span> 命中查询缓存、会在查询缓存返回结果时进行权限验证</span><br><span class="line"><span class="number">2.</span> 非命中 先验证权限、无 <span class="operator">-</span><span class="operator">&gt;</span> 直接返回错误</span><br><span class="line">                    有 <span class="operator">-</span><span class="operator">&gt;</span> 执行<span class="keyword">SQL</span></span><br><span class="line"><span class="number">3.</span> eg. mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> T <span class="keyword">where</span> ID<span class="operator">=</span><span class="number">10</span>;</span><br><span class="line">       </span><br><span class="line">    若 id 无索引:</span><br><span class="line">    <span class="number">1</span>) 调用innodb引擎接口查询第一行、若id <span class="operator">=</span> <span class="number">10</span>、存入结果集、否则 跳过、继续</span><br><span class="line">    <span class="number">2</span>) 调用引擎接口取下一行、直至最后一行</span><br><span class="line">    <span class="number">3</span>) 执行器将满足结果的行作为结果集返回给client</span><br><span class="line">    </span><br><span class="line">    若id 有索引:</span><br><span class="line">    <span class="number">1</span>) 调用innodb查询 满足条件的 第一行、放入结果集</span><br><span class="line">    <span class="number">2</span>) 查询满足条件的下一行..</span><br><span class="line">    <span class="number">3</span>) 将结果集返回给client</span><br><span class="line">  </span><br><span class="line">  在db慢<span class="keyword">SQL</span>中、有一个 rows_examined 字段、表示在<span class="keyword">SQL</span>执行过程中扫描了多少行、</span><br><span class="line">  是在 执行器 调用 引擎 获取数据行的时候累计的、</span><br><span class="line">  注：有些情况下、执行器调用一次会扫描很多行、所以 实际扫描行数 <span class="operator">!=</span> rows_examined</span><br><span class="line">    </span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/03/20/mysql_SQL%E6%9B%B4%E6%96%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="niuniu">
      <meta itemprop="description" content="多数是学习笔记、偶尔发发感慨、给生活添加些许乐趣">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="牛牛的小窝">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/20/mysql_SQL%E6%9B%B4%E6%96%B0/" class="post-title-link" itemprop="url">SQL更新</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-03-20 00:00:00" itemprop="dateCreated datePublished" datetime="2020-03-20T00:00:00+08:00">2020-03-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-05-07 11:31:06" itemprop="dateModified" datetime="2022-05-07T11:31:06+08:00">2022-05-07</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/MySQL/" itemprop="url" rel="index"><span itemprop="name">MySQL</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="redolog-重做日志-innodb引擎层特有"><a href="#redolog-重做日志-innodb引擎层特有" class="headerlink" title="redolog(重做日志 - innodb引擎层特有)"></a>redolog(重做日志 - innodb引擎层特有)</h4><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">MySQL使用AWL(<span class="keyword">Write</span>-Ahead Logging)技术, 当有记录需要更新的时候、innodb就先把记录写到redo <span class="keyword">log</span>、并更新内存、这时、更新就算完成. 当innodb引擎比较空闲的时候、会将操作更新到磁盘</span><br><span class="line"></span><br><span class="line">触发更新的点:</span><br><span class="line"><span class="number">1.</span> redo <span class="keyword">log</span> 写满时(redo <span class="keyword">log</span>文件大小是固定的 - 循环覆盖) </span><br><span class="line">   <span class="keyword">write</span> pos: 当前位置 </span><br><span class="line">   <span class="keyword">check</span> <span class="type">point</span>: 当前要擦除的位置</span><br><span class="line">   <span class="keyword">write</span>和<span class="keyword">check</span>间有空间、就代表可更新、否则、就要先擦除记录、推进<span class="keyword">checkpoint</span>、</span><br><span class="line"><span class="number">2.</span> </span><br></pre></td></tr></table></figure>
<p><img src="https://upload-images.jianshu.io/upload_images/14027542-e22222b71aa4fb6f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/340" alt="image.png"></p>
<h4 id="binlog-归档日志-MySQL-server层实现"><a href="#binlog-归档日志-MySQL-server层实现" class="headerlink" title="binlog(归档日志 - MySQL server层实现)"></a>binlog(归档日志 - MySQL server层实现)</h4><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql引擎实现的日志、与<span class="keyword">redo</span> <span class="keyword">log</span> 的差异？</span><br><span class="line"><span class="number">1.</span> <span class="keyword">redo</span> <span class="keyword">log</span> 是innodb特有的; binlog是mysql server层实现、所有引擎可以使用</span><br><span class="line"><span class="number">2.</span> <span class="keyword">redo</span> <span class="keyword">log</span> 记录的是物理日志、记录的是<span class="string">&quot;在某个数据页上做了什么修改&quot;</span></span><br><span class="line">   binlog 是逻辑日志、记录的是原始逻辑、eg. 给id=<span class="number">2</span>的c字段+<span class="number">1</span></span><br><span class="line"><span class="number">3.</span> <span class="keyword">redo</span> <span class="keyword">log</span> 循环写、空间固定 </span><br><span class="line">    binlog 是追加写、日志写满会切换到下一个</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="为什么有redo-log-和-binlog-？"><a href="#为什么有redo-log-和-binlog-？" class="headerlink" title="为什么有redo log 和 binlog ？"></a>为什么有redo log 和 binlog ？</h4><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sync_binlog: <span class="number">1</span> - 每次都持久化到磁盘</span><br><span class="line">binlog: statment格式、记录的是<span class="keyword">sql</span>语句、</span><br><span class="line">           <span class="keyword">row</span>格式、记录的是行内容、更新前后都有</span><br><span class="line"></span><br><span class="line">mysql整体包含: </span><br><span class="line"><span class="keyword">server</span>层 - 主要做的是mysql功能层面的事情、</span><br><span class="line">引擎层 - 负责存储</span><br><span class="line">最初、mysql无innodb引擎、MySQL自带的引擎是myisam、但它没有crash-safe的能力、<span class="keyword">server</span>层的binlog日志、只能用于归档、innodb是另外一个公司以插件形式引入、用redo <span class="keyword">log</span> 来实现crash-safe能力</span><br></pre></td></tr></table></figure>

<h4 id="update语句执行"><a href="#update语句执行" class="headerlink" title="update语句执行"></a>update语句执行</h4><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">update table <span class="keyword">set</span> c=c+<span class="number">1</span> <span class="keyword">where</span> <span class="built_in">id</span>=<span class="number">2</span></span><br><span class="line"><span class="number">1.</span> 执行器先找引擎取 <span class="built_in">id</span>=<span class="number">2</span> 这一行、<span class="built_in">id</span>是主键、引擎可以直接使用树搜索找到. 若 <span class="built_in">id</span> = <span class="number">2</span> 所在的数据页本来就在内存中、直接返回给执行器; 否则、先从磁盘读入内存、再返回</span><br><span class="line"><span class="number">2.</span> 执行器拿到引擎给出的数据行、把值 +<span class="number">1</span> 、得到新的一行数据、再调用引擎接口写入新的数据行</span><br><span class="line"><span class="number">3.</span> 引擎将新的数据行更新到内存、同时将更新操作记录到 redo <span class="built_in">log</span>. 此时redo <span class="built_in">log</span> 处于 prepare 状态、然后告诉执行器、执行完成、随时可以提交事务.</span><br><span class="line"><span class="number">4.</span> 执行器生成操作的binlog、并把binlog写入磁盘</span><br><span class="line"><span class="number">5.</span> 执行器调用引擎的提交事务接口、引擎把刚刚写入的redo <span class="built_in">log</span>改成commit状态、更新完成</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="https://upload-images.jianshu.io/upload_images/14027542-7b1034b758d49c13.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/340" alt="update.png"></p>
<h4 id="为什么需要两阶段提交"><a href="#为什么需要两阶段提交" class="headerlink" title="为什么需要两阶段提交"></a>为什么需要两阶段提交</h4><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">redo</span> <span class="keyword">log</span> 和 binlog 是两个独立的逻辑、若不使用两阶段提交、则会是<span class="number">2</span>种情况</span><br><span class="line"><span class="number">1.</span> 先 <span class="keyword">redo</span> <span class="keyword">log</span>、 后binlog</span><br><span class="line">   若redolog完成、binlog未完成、进程异常重启、<span class="keyword">redo</span> <span class="keyword">log</span>生效、为修改后的值 </span><br><span class="line">  若使用binlog恢复临时库、由于binlog未写完就崩溃、会少一条记录、源库和备库就会出现不一致</span><br><span class="line"><span class="number">2.</span> 先binlog、后 <span class="keyword">redo</span> <span class="keyword">log</span></span><br><span class="line">    binlog写完后crash、<span class="keyword">redo</span> <span class="keyword">log</span>未写、在恢复时、认为事务无效、</span><br><span class="line">    binlog已写完、恢复备份库时、认为有效、出现不一致...</span><br><span class="line">所以、为了保证<span class="keyword">redo</span> <span class="keyword">log</span> 和 binlog提交状态的逻辑一致性</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="疑问"><a href="#疑问" class="headerlink" title="疑问"></a>疑问</h4><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1. binlog 是每次<span class="keyword">update</span>都会写磁盘？</span><br><span class="line"><span class="number">2.</span> 如果 redo <span class="built_in">log</span> 第一阶段完成(<span class="keyword">prepare</span>状态)、binlog完成、此时crash、在系统重启之后、这个<span class="built_in">log</span>会被重放吗</span><br><span class="line">   会、满足<span class="keyword">prepare</span> 和 binlog的完整、在重启时、会自动执行<span class="keyword">commit</span></span><br><span class="line"><span class="number">3.</span> 极端情况下、redo <span class="built_in">log</span>被写满、新的事务进入、需要擦除redo <span class="built_in">log</span>(被修改的脏页被迫刷新到磁盘) -&gt; 数据在 <span class="keyword">commit</span> 之前被持久化、此时如何处理 ？</span><br><span class="line">这些数据在内存中属于无效事务、其它事务读不到、即时被写入磁盘也没关系、再次读入内存时、依然是原逻辑</span><br><span class="line"><span class="number">4.</span> redo <span class="built_in">log</span> 是顺序写 ？ binlog是随机写 ？</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/03/20/mysql_java-jdbc%E5%8F%82%E6%95%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="niuniu">
      <meta itemprop="description" content="多数是学习笔记、偶尔发发感慨、给生活添加些许乐趣">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="牛牛的小窝">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/20/mysql_java-jdbc%E5%8F%82%E6%95%B0/" class="post-title-link" itemprop="url">java-jdbc参数</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-03-20 00:00:00" itemprop="dateCreated datePublished" datetime="2020-03-20T00:00:00+08:00">2020-03-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-05-07 11:31:06" itemprop="dateModified" datetime="2022-05-07T11:31:06+08:00">2022-05-07</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/MySQL/" itemprop="url" rel="index"><span itemprop="name">MySQL</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <table>
<thead>
<tr>
<th>参数名称</th>
<th>参数说明</th>
<th>缺省值</th>
<th>版本</th>
</tr>
</thead>
<tbody><tr>
<td>user</td>
<td>数据库用户名</td>
<td></td>
<td>all</td>
</tr>
<tr>
<td>password</td>
<td>密码</td>
<td></td>
<td>all</td>
</tr>
<tr>
<td>useUnicode</td>
<td>是否使用unicode字符集、若characterEncoding设置为gb2312或者gbk、则必须设置为true</td>
<td>false</td>
<td>&gt;1.1</td>
</tr>
<tr>
<td>characterEncoding</td>
<td>指定字符编码</td>
<td>false</td>
<td>&gt;1.1</td>
</tr>
<tr>
<td>autoReconnect</td>
<td>db异常时、是否自动重连？</td>
<td>false</td>
<td>1.1</td>
</tr>
<tr>
<td>autoReconnectForPools</td>
<td>是否使用针对db 连接池的重连策略</td>
<td>false</td>
<td>1.1</td>
</tr>
<tr>
<td>failOverReadOnly</td>
<td>自动重连成功后、连接是否设为只读</td>
<td>true</td>
<td>3.0.12</td>
</tr>
<tr>
<td>maxReconnects</td>
<td>autoReconnect设为true时、重试次数</td>
<td>3</td>
<td>1.1</td>
</tr>
<tr>
<td>initalTimeout</td>
<td>autoReconnect为true时、两次重试之间的时间间隔</td>
<td>2s</td>
<td>1.1</td>
</tr>
<tr>
<td>connectTimeOut</td>
<td>和数据库建立socket连接的超时时间ms</td>
<td>0-永不超时</td>
<td>3.0.1</td>
</tr>
<tr>
<td>socketTimeOut</td>
<td>socket读写超时ms</td>
<td>0-永不超时</td>
<td>3.0.1</td>
</tr>
<tr>
<td>zeroDateTimeBehavior</td>
<td>将db 0值转化为null</td>
<td></td>
<td>3.1.4</td>
</tr>
</tbody></table>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/03/20/mysql_mysql-%E7%B4%A2%E5%BC%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="niuniu">
      <meta itemprop="description" content="多数是学习笔记、偶尔发发感慨、给生活添加些许乐趣">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="牛牛的小窝">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/20/mysql_mysql-%E7%B4%A2%E5%BC%95/" class="post-title-link" itemprop="url">mysql索引</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-03-20 00:00:00" itemprop="dateCreated datePublished" datetime="2020-03-20T00:00:00+08:00">2020-03-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-05-07 11:31:06" itemprop="dateModified" datetime="2022-05-07T11:31:06+08:00">2022-05-07</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/MySQL/" itemprop="url" rel="index"><span itemprop="name">MySQL</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="常见的索引模型"><a href="#常见的索引模型" class="headerlink" title="常见的索引模型"></a>常见的索引模型</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">1.</span> hash 一种key-value结构、k-v映射、写入、等值查询很快、但范围查询比较慢、但适用于 等值查询的场景</span><br><span class="line"><span class="bullet">2.</span> 有序数组在等值查询和范围查询的性能表现上都很优秀</span><br><span class="line">   但在插入时必须要挪动后续所有记录、成本太高、</span><br><span class="line">   所以只适用于静态存储. eg. 城市信息表这种不经常变动的数据</span><br><span class="line"><span class="bullet">3.</span> 树 在查询和写入的效率上都还不错</span><br></pre></td></tr></table></figure>
<p><img src="https://upload-images.jianshu.io/upload_images/14027542-378ce5505cc95e86.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="hash表示意图.png"></p>
<h4 id="innodb的索引模型"><a href="#innodb的索引模型" class="headerlink" title="innodb的索引模型"></a>innodb的索引模型</h4><blockquote>
<p>在innodb中、表都是根据主键顺序、以索引的形式存放的, 这种存储方式的表称为索引组织表<br>innodb使用了B+树索引模型，数据都是存储在B+树的、每个索引对应一颗B+树</p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> T<span class="operator">-</span>inx(</span><br><span class="line">id <span class="type">int</span> <span class="keyword">primary</span> key ,</span><br><span class="line">k <span class="type">int</span> <span class="keyword">not</span> <span class="keyword">null</span> ,</span><br><span class="line">name <span class="type">varchar</span>(<span class="number">16</span>) ,</span><br><span class="line">index (k)</span><br><span class="line">)engine<span class="operator">=</span>innodb</span><br></pre></td></tr></table></figure>
<p><img src="https://upload-images.jianshu.io/upload_images/14027542-4047d1069d4fce5c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="i索引树示意图.png"></p>
<figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">从图中可以看出、索引树分为主键索引和非主键索引两种类型、</span><br><span class="line">主键索引存储的是整行数据、在innodb里, 主键索引也被称为聚簇索引(clustered <span class="keyword">index</span>).</span><br><span class="line">非主键索引的叶子节点内容是主键值, 也称为二级索引(secondary <span class="keyword">index</span>).</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>Q: 那么基于主键索引 和 基于普通索引的查询有什么区别 ?</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">若 <span class="keyword">sql</span> 是 <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> T <span class="keyword">where</span> ID<span class="operator">=</span><span class="number">500</span>; 即主键查询的方式、则只需要搜索ID这颗 B<span class="operator">+</span> 树</span><br><span class="line">若 <span class="keyword">sql</span> 是 <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> T <span class="keyword">where</span> k<span class="operator">=</span><span class="number">5</span>, 则需要先搜索k这颗索引树、得到id的值为<span class="number">500</span>, 再到ID索引树搜索一次、这个过程称为 回表</span><br><span class="line"></span><br><span class="line">也就是: 基于非主键索引的查询需要多扫描一颗索引树, 所以需要尽量的使用主键查询</span><br></pre></td></tr></table></figure>

<p>Q: 索引维护</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">B+ 树为了维护索引有序性、在插入新值的时候需要做必要的维护.</span><br><span class="line">若插入的新值较大、只需要再最后插入新的记录、若插入的值为中间值、则相对麻烦,需要先挪动后边的数据、腾出位置</span><br><span class="line"><span class="section">更糟糕的是: 若最后一个数据所在的数据页已经满了、根据B+树的算法、需要申请一个新的数据页、然后挪动部分数据过去</span></span><br><span class="line">这个过程称为 页分裂, 除了性能外、页分裂还影响数据页的利用率</span><br><span class="line"></span><br><span class="line">当相邻页有数据删除之后、由于数据页的利用率很低、会进行页合并</span><br><span class="line"></span><br><span class="line"><span class="section">场景: 自增主键的作用？</span></span><br><span class="line">插入新的记录时、系统会获取当前最大值+1 作为下一条记录的id</span><br><span class="line"><span class="section">即: 自增主键的插入数据模式、正好符合了递增插入、不涉及挪动其它记录、也不会触发叶子节点的分裂</span></span><br><span class="line">而有业务逻辑的字段做主键、则往往不能保证有序写入、这样写数据的成本相对高</span><br><span class="line"></span><br><span class="line">从存储上看、主键长度越小、普通索引的叶子节点就越小、索引占用的空间也就越小</span><br><span class="line"></span><br><span class="line">so. 从性能和存储上来看、自增主键往往是最合理的选择</span><br></pre></td></tr></table></figure>


<p>表初始化语句</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> T<span class="operator">-</span>index(</span><br><span class="line">ID <span class="type">int</span> <span class="keyword">primary</span> key, </span><br><span class="line">k <span class="type">int</span> <span class="keyword">not</span> <span class="keyword">null</span> <span class="keyword">default</span> <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">index k(k)</span><br><span class="line">)engine<span class="operator">=</span>Innodb;</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> T<span class="operator">-</span>index <span class="keyword">values</span> (<span class="number">100</span>, <span class="number">1</span>, <span class="string">&#x27;aa&#x27;</span>), (<span class="number">200</span>, <span class="number">2</span>, <span class="string">&#x27;bb&#x27;</span>), (<span class="number">300</span>, <span class="number">3</span>, <span class="string">&#x27;cc&#x27;</span>), , (<span class="number">500</span>, <span class="number">5</span>, <span class="string">&#x27;ee&#x27;</span>), (<span class="number">600</span>, <span class="number">6</span>,<span class="string">&#x27;ff&#x27;</span>),(<span class="number">700</span>,<span class="number">7</span>,<span class="string">&#x27;gg&#x27;</span>);</span><br><span class="line">                                                                                                     </span><br></pre></td></tr></table></figure>

<p>Q: 执行sql<code>select * from T-index where k between 3 and 5</code>需要执行几次树的搜搜操作、会扫描多少行 ？<br>A: 执行流程:</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1. 在 k 索引树上找到 <span class="attribute">k</span>=3 的记录、取得<span class="attribute">id</span>=300;</span><br><span class="line">2. 再到 id 索引树上查找 <span class="attribute">id</span>=300 对应的记录R3;</span><br><span class="line">3. 在 k 索引树上找到 下一个值 <span class="attribute">k</span>=5, 取得 <span class="attribute">id</span>=500;</span><br><span class="line">4. 再回到 id 索引树上找到 <span class="attribute">id</span>=500 对应的记录 R4;</span><br><span class="line">5. 在k索引树上取下一个值 <span class="attribute">k</span>=6, 不满足条件、循环两次.</span><br><span class="line"></span><br><span class="line">在步骤 2、4中、回到主键索引查找数据的过程、称为回表</span><br></pre></td></tr></table></figure>
<p>所以、一共执行了 <code>3次</code>搜索、<code>2次</code>回表、扫描<code>3行</code></p>
<h4 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h4><blockquote>
<p>若执行的语句是<br>select ID from T-index where k between 3 and 5;<br>此时只需要查询 ID 的值、而ID的值已经在 K 索引树上了、可以直接提供查询结果、<br>无需回表、即: 在本次查询中、索引 k 已经覆盖了查询需求、<br>称为覆盖索引</p>
</blockquote>
<ul>
<li>在引擎内部使用覆盖索引在索引 k 上其实读了3个记录、R3~R5、<br>但是对于 MySQL的server来说、只从引擎拿到了2条记录、认为扫描行是2</li>
</ul>
<p>so. 覆盖索引在一定程度上可以减少回表扫描的次数</p>
<p>Q: 在一个市民表上、是否有必要将身份证和名字建立联合索引 ?</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span>  <span class="keyword">table</span> `<span class="keyword">user</span>` (</span><br><span class="line">`id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">not</span> <span class="keyword">null</span> ,</span><br><span class="line">`id_card` <span class="type">varchar</span>(<span class="number">32</span>) <span class="keyword">default</span> <span class="keyword">null</span> ,</span><br><span class="line">`name` <span class="type">varchar</span>(<span class="number">32</span>) <span class="keyword">default</span> <span class="keyword">null</span> ,</span><br><span class="line">`age` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">default</span> <span class="keyword">null</span> , </span><br><span class="line">`ismale` tinyint(<span class="number">1</span>) <span class="keyword">default</span> <span class="keyword">null</span> ,</span><br><span class="line"><span class="keyword">PRIMARY</span> key (`id`) ,</span><br><span class="line">key `id_card` (`id_card`),</span><br><span class="line">key `name_age` (`name`, `age`)</span><br><span class="line">) engine<span class="operator">=</span>Innodb</span><br></pre></td></tr></table></figure>
<p>A: </p>
<figure class="highlight nestedtext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">这种情况需要看实际的业务场景</span><span class="punctuation">:</span></span><br><span class="line"><span class="attribute">1. 若经常的查询需求是</span><span class="punctuation">: </span></span><br><span class="line">   <span class="attribute">根据身份证号查询市民信息、则 只需要在身份证字段上建立索引, 再建(id,name)的联合索引就会浪费空间</span></span><br><span class="line"><span class="attribute">   </span></span><br><span class="line"><span class="attribute">2. 若经常的查询需求是</span><span class="punctuation">:</span></span><br><span class="line">   根据身份证号查询name, 则建立联合索引就有很大的意义、它可以在这个高频请求上用到覆盖索引, </span><br><span class="line">   不在需要回表查询， 提高查询速度</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>Q: 如果现在有一个非高频请求、根据身份证号查询家庭地址, 需要再设计一个联合索引么 ?<br>A: </p>
<figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">索引项是按照索引出现的字段排序的:</span><br><span class="line">eg. 利用(<span class="keyword">name</span>, age)的联合索引查找所有名字是 zhangsan 的人时, 可快速定位到 ID4, 然后向后遍历得到所有结果</span><br><span class="line">    不只是索引的全部定义. 只要满足最左前缀原则、就可以利用索引来加速检索</span><br><span class="line">所以: 基于已经建立了 (id_card, <span class="keyword">name</span>) 的联合索引、无需再建立 (id_card, addr)的联合索引、</span><br><span class="line">利用最左前缀的原则、它可以使用 (id_card, <span class="keyword">name</span>) 的联合索引</span><br></pre></td></tr></table></figure>

<h4 id="索引下推"><a href="#索引下推" class="headerlink" title="索引下推"></a>索引下推</h4><p>思考:<br>以(name, age)联合索引为例、需要检索所有 <strong>名字第一个字为张,且年龄为10的男孩</strong><br>SQL如下:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> name <span class="keyword">like</span> `张<span class="operator">%</span>` <span class="keyword">and</span> age<span class="operator">=</span><span class="number">10</span> <span class="keyword">and</span> ismale<span class="operator">=</span><span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p>拿到记录行之后、还要进一步判断其它条件是否满足、这个怎么处理的呢?</p>
<figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>. 在MySQL <span class="number">5.6</span> 之前、只能从 ID3 开始、一个个回表. 在主键索引上找到数据行、再对比字段值</span><br><span class="line"><span class="number">2</span>. 在<span class="number">5.6</span> 引入了索引下推(index condition pushdown), 可以在索引遍历的过程中对索引包含的字段优先判断</span><br><span class="line">   过滤掉不满足条件的记录、减少回表次数</span><br><span class="line">   </span><br><span class="line">   在无索引下推时、innodb不会看age的值、只是顺序把 `name`第一个字是`张`的记录取出、回表、需要回表<span class="number">4</span>次</span><br><span class="line">   有索引下推时、innodb在(name, age)内部就判断了age是否=<span class="number">10</span>，不等于<span class="number">10</span>的记录、直接判断并跳过</span><br><span class="line">   只需要取回ID4、ID5两条记录、所以只需要回表<span class="number">2</span>次</span><br></pre></td></tr></table></figure>
<p>Q: 为什么需要重建索引？</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">索引因为删除、或者页分裂等原因、导致数据页有空洞、重建索引的过程会创建一个新的索引、把数据按顺序插入、这样页面的利用率最高、</span><br><span class="line">也就是索引更紧凑、更省空间</span><br></pre></td></tr></table></figure>
<p>Q: </p>
<figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">场景:</span> DBA入职时、发现自己接手维护的库、有一个表定义：</span><br><span class="line"></span><br><span class="line">create table `geek`(</span><br><span class="line">`a` int(<span class="number">11</span>) <span class="literal">not</span> null,</span><br><span class="line">`b` int(<span class="number">11</span>) <span class="literal">not</span> null,</span><br><span class="line">`c` int(<span class="number">11</span>) <span class="literal">not</span> null,</span><br><span class="line">`d` int(<span class="number">11</span>) <span class="literal">not</span> null,</span><br><span class="line">primary key(`a`, `b`),</span><br><span class="line">key `c`(`c`),</span><br><span class="line">key `ca`(`c`, `a`),</span><br><span class="line">key `cb`(`c`, `b`)</span><br><span class="line">)engine=innodb<span class="comment">;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>为什么需要ca、cb这两个联合索引呢 ？同事的解释是: 因为业务常用下边的sql:</p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> geek <span class="keyword">where</span> c<span class="operator">=</span>N <span class="keyword">order</span> <span class="keyword">by</span> a limit <span class="number">1</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> geek <span class="keyword">where</span> c<span class="operator">=</span>N <span class="keyword">order</span> <span class="keyword">by</span> b limit <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>那么这种解释对么 ？</p>
</blockquote>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">主键<span class="selector-tag">a</span>、<span class="selector-tag">b</span>的聚簇索引组织顺序相当于 <span class="selector-tag">order</span> <span class="selector-tag">by</span> <span class="selector-tag">a</span>, <span class="selector-tag">b</span> 即: 先按<span class="selector-tag">a</span>排序、再按<span class="selector-tag">b</span>排序、<span class="selector-tag">c</span>无序</span><br><span class="line">索引 <span class="selector-tag">ca</span>的组织是先按<span class="selector-tag">c</span>排序、再按<span class="selector-tag">a</span>排序、同时记录主键<span class="selector-tag">b</span></span><br><span class="line">索引 <span class="selector-tag">cb</span>的组织是先按<span class="selector-tag">c</span>排序、再按<span class="selector-tag">b</span>排序、同时记录主键<span class="selector-tag">a</span></span><br><span class="line"><span class="selector-tag">so</span>. <span class="selector-tag">ca</span>可以去掉、<span class="selector-tag">cb</span>需要保留</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>Q: using where的时候、需要回表查询数据、然后把数据传输给server层、server来过滤数据、那么这些数据是存在哪儿的呢 ？</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">无需存储、就是一个临时表、读出来立马判断、然后扫描下一行是否可以复用</span><br></pre></td></tr></table></figure>

<p>Q: limit起到限制扫描行数的作用、并且有using where的时候、limit这个操作在存储引擎层做的、还是在server层做的 ？</p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">server</span>层、接上面一个Q、读完以后、顺便判断一下<span class="keyword">limit</span>够不够就可以了、够了就结束循环</span><br></pre></td></tr></table></figure>

<p>Q: extra列线上 using index condition 代表使用了索引下推 ?</p>
<figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ICP代表可以下推、但 &#x27;可以、不一定是&#x27;</span><br></pre></td></tr></table></figure>

<p>Q: 备库使用 –single-transaction 做逻辑备份的时候、若从主库的binlog传来一个DDL语句会如何?<br>A:备份关键语句:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Q1:<span class="keyword">SET</span> SESSION TRANSACTION ISOLATION LEVEL REPEATABLE READ;</span><br><span class="line">Q2:<span class="keyword">START</span> TRANSACTION  <span class="keyword">WITH</span> CONSISTENT SNAPSHOT;</span><br><span class="line"><span class="comment">/* other tables */</span></span><br><span class="line">Q3:<span class="keyword">SAVEPOINT</span> sp;</span><br><span class="line"><span class="comment">/* 时刻 1 */</span></span><br><span class="line">Q4:<span class="keyword">show</span> <span class="keyword">create</span> <span class="keyword">table</span> `t1`;</span><br><span class="line"><span class="comment">/* 时刻 2 */</span></span><br><span class="line">Q5:<span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> `t1`;</span><br><span class="line"><span class="comment">/* 时刻 3 */</span></span><br><span class="line">Q6:<span class="keyword">ROLLBACK</span> <span class="keyword">TO</span> <span class="keyword">SAVEPOINT</span> sp;</span><br><span class="line"><span class="comment">/* 时刻 4 */</span></span><br><span class="line"><span class="comment">/* other tables */</span></span><br></pre></td></tr></table></figure>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">在备份开始的时候、为了确保RR(可重复读)、再设置一次隔离级别<span class="built_in">Q1</span></span><br><span class="line">启动事务、用 with consistent snapshot 来确保这个语句执行完可以得到一个一致性视图 <span class="built_in">Q2</span></span><br><span class="line">设置保存点 <span class="built_in">Q3</span></span><br><span class="line"><span class="symbol">show</span> create 是为了那点表结构 <span class="built_in">Q4</span>、正式导数据 <span class="built_in">Q5</span> 回滚到savepoint ap是为了释放t1的MDL锁 <span class="built_in">Q6</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">DDL</span>从主库传过来的时间不同、则影响不同</span><br><span class="line"><span class="number">1</span>. 若在<span class="built_in">Q4</span>之前到达: 无影响、那点的是DDL后的表结构</span><br><span class="line"><span class="number">2</span>. 若在时刻<span class="number">2</span>到达、表结构被修改过、<span class="built_in">Q5</span>执行的时候、报 Table definition has changed. please retry transaction. mysqldump 终止</span><br><span class="line"><span class="number">3</span>. 在时刻<span class="number">2</span> 和 <span class="number">3</span>之间到达、mysqldump占着t1的MDL锁、binlog被阻塞、现象: 主从延迟、直到 <span class="built_in">Q6</span> 完成.</span><br><span class="line"><span class="number">4</span>. 从时刻<span class="number">2</span>开始、mysqldump释放了 MDL锁、现象: 无影响、备份拿到的是 DDL前 的表结构</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>Q: </p>
<blockquote>
<p>删除100000行表记录时,有3种做法</p>
</blockquote>
<ol>
<li>直接delete from T limit 100000;</li>
<li>在一个连接中 delete from T limit 5000; loop 20</li>
<li>在20个连接中 delete from T limit 5000; 20 connections;<br>如何选择?</li>
</ol>
<p>A:</p>
<figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">尽量的选择第二种方式</span><br><span class="line">1. 单个语句占用的时间较长、锁的时间也会较长、而且打的事务也会造成主从延迟</span><br><span class="line">3. 在20个连接中同时执行 <span class="keyword">delete</span> <span class="keyword">from</span> T <span class="keyword">limit</span> <span class="number">5000</span>, 可能会造成认为锁冲突</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/03/20/mysql_mysql%E4%BA%8B%E5%8A%A1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="niuniu">
      <meta itemprop="description" content="多数是学习笔记、偶尔发发感慨、给生活添加些许乐趣">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="牛牛的小窝">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/20/mysql_mysql%E4%BA%8B%E5%8A%A1/" class="post-title-link" itemprop="url">mysql事务</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-03-20 00:00:00" itemprop="dateCreated datePublished" datetime="2020-03-20T00:00:00+08:00">2020-03-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-05-07 11:31:06" itemprop="dateModified" datetime="2022-05-07T11:31:06+08:00">2022-05-07</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/MySQL/" itemprop="url" rel="index"><span itemprop="name">MySQL</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="mysql-事务"><a href="#mysql-事务" class="headerlink" title="mysql 事务"></a>mysql 事务</h3><ol>
<li><p>ACID原则:</p>
<figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">Automicity:</span> 原子性</span><br><span class="line"><span class="symbol">Consistency:</span> 一致性</span><br><span class="line"><span class="symbol">Isolation:</span> 隔离性</span><br><span class="line"><span class="symbol">Durability:</span> 持久性</span><br></pre></td></tr></table></figure>

</li>
<li><p>SQL隔离级别</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">1.</span> 读未提交: read uncommited, 事务未提交时、别的事务就能读到它的变更</span><br><span class="line"><span class="bullet">2.</span> 读提交: read commited, 事务提交之后、才能被别的事务读到变更</span><br><span class="line"><span class="bullet">3.</span> 可重复读: repeatable read, 事务在执行过程中看到的数据、始终保持跟事务启动时看到的一致</span><br><span class="line"><span class="bullet">4.</span> 串行化: seriable, 对同一记录、写会加写锁、读会加读锁、读写锁冲突的时候、必须等到前一个锁释放才能执行</span><br></pre></td></tr></table></figure></li>
</ol>
<p><img src="https://upload-images.jianshu.io/upload_images/14027542-374aecc9f9ddf1bd.png?imageMogr2/auto-orient/strip%7CimageView2/1/w/240" alt="image.png"></p>
<h4 id="不同事物隔离级别下、事物A的返回结果"><a href="#不同事物隔离级别下、事物A的返回结果" class="headerlink" title="不同事物隔离级别下、事物A的返回结果"></a>不同事物隔离级别下、事物A的返回结果</h4><ul>
<li>若隔离级别是<code>读未提交</code>, 则 <code>V1</code> 的值是<code>2</code>、此时、B未提交A可以读到、<br><code>V2</code>, <code>V3</code> 的值也都是2</li>
<li>若.. 是<code>读提交</code>, 则<code>V1</code>是1、<code>V2</code> 是2、事物B的更新在提交后可以被A读到、则<code>V3</code>的值也是2</li>
<li>若隔离级别是<code>可重复读</code>、则<code>V1</code>, <code>V2</code>的值是1、<code>V3</code>的值2、因为<code>V2</code>在<code>事务A</code>提交之前、所以、<code>V1</code>, <code>V2</code> 的值为1</li>
<li>若隔离级别是<code>可串行化</code> 则<code>事务B</code>在执行<code>1-&gt;2</code>的过程会被锁、直到A提交、所以<code>V1</code>, <code>V2</code>是1 、</li>
</ul>
<h4 id="查看事务隔离级别"><a href="#查看事务隔离级别" class="headerlink" title="查看事务隔离级别"></a>查看事务隔离级别</h4><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">mysql&gt; show variables like &#x27;transaction_isolation&#x27;;</span></span><br><span class="line"><span class="section">+-----------------------+-----------------+</span></span><br><span class="line"><span class="section">| Variable_name         | Value           |</span></span><br><span class="line"><span class="section">+-----------------------+-----------------+</span></span><br><span class="line"><span class="section">| transaction_isolation | REPEATABLE-READ |</span></span><br><span class="line"><span class="section">+-----------------------+-----------------+</span></span><br><span class="line">1 row in set (0.04 sec)</span><br></pre></td></tr></table></figure>

<figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">mysql&gt; select @@transaction_isolation;</span></span><br><span class="line"><span class="section">+-----------------+</span></span><br><span class="line"><span class="section">| @@transaction_isolation  |</span></span><br><span class="line"><span class="section">+-----------------+</span></span><br><span class="line"><span class="section">| REPEATABLE-READ |</span></span><br><span class="line"><span class="section">+-----------------+</span></span><br></pre></td></tr></table></figure>

<h5 id="mysql-全局事务隔离级别修改后、在本会话不会生效、只影响后续会话"><a href="#mysql-全局事务隔离级别修改后、在本会话不会生效、只影响后续会话" class="headerlink" title="mysql 全局事务隔离级别修改后、在本会话不会生效、只影响后续会话"></a>mysql 全局事务隔离级别修改后、在本会话不会生效、只影响后续会话</h5><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; set global transaction isolation level read committed;</span><br><span class="line">Query OK, 0 rows affected (0.01 sec)</span><br><span class="line"></span><br><span class="line"><span class="section">mysql&gt; select @@transaction_isolation;</span></span><br><span class="line"><span class="section">+-------------------------+</span></span><br><span class="line"><span class="section">| @@transaction_isolation |</span></span><br><span class="line"><span class="section">+-------------------------+</span></span><br><span class="line"><span class="section">| REPEATABLE-READ         |</span></span><br><span class="line"><span class="section">+-------------------------+</span></span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="mysql-session级别事务修改、只影响当前会话"><a href="#mysql-session级别事务修改、只影响当前会话" class="headerlink" title="mysql session级别事务修改、只影响当前会话"></a>mysql session级别事务修改、只影响当前会话</h5><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; set session  transaction isolation level read uncommitted;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line"><span class="section">mysql&gt; select @@transaction_isolation;</span></span><br><span class="line"><span class="section">+-------------------------+</span></span><br><span class="line"><span class="section">| @@transaction_isolation |</span></span><br><span class="line"><span class="section">+-------------------------+</span></span><br><span class="line"><span class="section">| READ-UNCOMMITTED        |</span></span><br><span class="line"><span class="section">+-------------------------+</span></span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>
<p>*Q: </p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1.合适需要RR级别呢 ？</span><br><span class="line">   假设正在对数据做校对、是不是希望在校对过程中、用户产生的交易不会影响校对的结果 ？~~</span><br><span class="line"><span class="bullet">2.</span> 回滚日志什么时候删除？</span><br><span class="line">系统会判断当没有事务需要用到这些回滚日志的时候，回滚日志会被删除</span><br><span class="line"><span class="bullet">3.</span> 什么时候不需要了？</span><br><span class="line">  当系统里么有比这个回滚日志更早的read-view的时候</span><br><span class="line"><span class="bullet">4.</span> 为什么尽量不要使用长事务</span><br><span class="line">  长事务意味着系统里面会存在很老的事务视图，在这个事务提交之前，回滚记录都要保留，这会导致大量占用存储空间。除此之外，长事务还占用锁资源，可能会拖垮库</span><br><span class="line"><span class="bullet">5.</span> </span><br></pre></td></tr></table></figure>

<h4 id="事务隔离的实现"><a href="#事务隔离的实现" class="headerlink" title="事务隔离的实现"></a>事务隔离的实现</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">事务隔离的实现：每条记录在更新的时候都会同时记录一条回滚操作。同一条记录在系统中可以存在多个版本，这就是数据库的多版本并发控制（MVCC）</span><br></pre></td></tr></table></figure>

<p>Q: 由上所述、若事务隔离级别为RR、事务T启动的时候会创建一个一致性视图read-view、执行期间、若有其它事务修改了数据、事务T看到的数据不变<br>但: 这个事务要更新R1时、恰好R1被T2占有行锁、则T会进入等待状态、此时: 当它拿到行锁、可以执行更新的时候、读到的值是什么呢 ？</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> `t`(</span><br><span class="line">`id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">not</span> <span class="keyword">null</span> , </span><br><span class="line">`k` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">default</span> <span class="keyword">null</span> ,</span><br><span class="line"><span class="keyword">primary</span> key (`id`)</span><br><span class="line">)engine<span class="operator">=</span>innodb;</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t(id, k) <span class="keyword">values</span> (<span class="number">1</span>, <span class="number">1</span>),(<span class="number">2</span>, <span class="number">2</span>);</span><br></pre></td></tr></table></figure>
<p>SQL执行顺序如下：<br><img src="https://upload-images.jianshu.io/upload_images/14027542-cd319103b6d27133.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/240" alt="image.png"></p>
<p>那么两个查询语句得到的结果分表是什么呢？</p>
<p>A: 先看下几个概念:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> <span class="keyword">begin</span><span class="operator">/</span><span class="keyword">start</span> transaction 并不是事务的七点、在执行到它们之后的第一个innodb表语句、事务才真正启动、马上执行事务、可以使用：</span><br><span class="line">   <span class="keyword">start</span> transaction <span class="keyword">with</span> consistent snapshot;</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span> mysql中两个视图的概念</span><br><span class="line">   <span class="number">1</span>) <span class="keyword">view</span>: 是用查询语句创建的虚拟表、在调用的时候执行查询语句并生成结果、<span class="keyword">create</span> <span class="keyword">view</span> ... </span><br><span class="line">   <span class="number">2</span>) innodb在实现MVCC时用到的一致性读视图、即 cinsistent read <span class="keyword">view</span>, 用于执行 RC(Read Committed, 读提交)</span><br><span class="line">       和RR(Repeatable Read, 可重复读)隔离级别的实现</span><br><span class="line">   </span><br></pre></td></tr></table></figure>
<blockquote>
<p>两种启动事务的方式<br>  1.一致性视图是在执行第一个快照语句时创建<br>  2 在执行 start transaction with consistent snapshot 时创建</p>
</blockquote>
<p>大前提:</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">1.</span> 事务隔离级别为RR</span><br><span class="line"><span class="bullet">2.</span> autocommit=1</span><br><span class="line"><span class="bullet">3.</span> 注意事务启动的时机</span><br></pre></td></tr></table></figure>
<p>结果:</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">A</span> 查询得到<span class="number">1</span> B查询得到<span class="number">3</span> C更新成功</span><br></pre></td></tr></table></figure>

<p>so. 一脸迷茫了、^.^…<br>来看下: 快照在MVCC里是如何工作的</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">在RR级别下、事务在启动的时候就拍了个快照(基于db)</span><br><span class="line"></span><br><span class="line">快照如何实现？</span><br><span class="line"><span class="number">1.</span> innodb每个事务有一个唯一<span class="built_in">id</span>、叫 <span class="keyword">transaction</span> <span class="built_in">id</span>. 在事务开始时向事务系统申请、严格递增</span><br><span class="line"><span class="number">2.</span> 每行数据有多个版本、每次更新都会生成一个新的数据版本、并把trx <span class="built_in">id</span>赋值给这个数据版本的事务<span class="built_in">id</span>、记为: row trx_id</span><br><span class="line">   旧的数据版本要保留、且在新的数据版本中可以拿到、即: 表中一行记录、有多个版本row、每个版本有自己的row trx_id</span><br><span class="line">   一个记录被连续更新后的状态如下:</span><br></pre></td></tr></table></figure>
<p><img src="https://upload-images.jianshu.io/upload_images/14027542-249460f611087ba6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/340" alt="image.png"></p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">虚线内是同一行数据的<span class="number">4</span>个版本、当前最新版本是V4、k的值是<span class="number">22</span>、是被 <span class="keyword">transaction</span> <span class="built_in">id</span> 为<span class="number">25</span>的事务更新的</span><br><span class="line"></span><br><span class="line">undo <span class="built_in">log</span>呢? </span><br><span class="line">上图中的三个虚线就是undo <span class="built_in">log</span>、而V1 V2 V3 并不是物理存在的、而是在需要的时候根据当前版本和undo <span class="built_in">log</span>计算的</span><br><span class="line">事务只认、事务启动之前提交的内容、如果提交之后的并不认、必须要找到它的上一个版本、若上一个版本也不可见、则继续查找</span><br><span class="line"></span><br><span class="line">实现: </span><br><span class="line">innodb为每个事务构造了一个数组、用来保存事务启动的瞬间、当前正在活跃(启动但未提交)的所有事务<span class="built_in">id</span></span><br><span class="line"></span><br><span class="line">数组里<span class="built_in">id</span>的最小值即为 低水位、当前系统已创建过的事务<span class="built_in">id</span>的最大值+<span class="number">1</span> 即为 高水位</span><br><span class="line">视图数组和高水位组成了当前事务的一致性视图 <span class="built_in">read</span>-view</span><br><span class="line">数据版本的可见性规则、就是基于row trx_id和一致性视图的对比结果得到的</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="https://upload-images.jianshu.io/upload_images/14027542-be120e1119794bcf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/340" alt="image.png"></p>
<figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">对于当前事务启动的瞬间、一个数据版本的<span class="built_in">row</span> trx_id有几种情况</span><br><span class="line"><span class="number">1</span>. 若落在绿色部分、表示已提交事务或当前事务自己生成的、可见</span><br><span class="line"><span class="number">2</span>. 红色部分、表示这个版本是将来启动的事务生成的、不可见</span><br><span class="line"><span class="number">3</span>. 黄色部分、</span><br><span class="line">   a. 若 <span class="built_in">row</span> trx_id 在数组中、表示由未提交的事务生成的、不可见</span><br><span class="line">   b. 若不在数组中、表示已提交事务生成、可见</span><br><span class="line">   </span><br><span class="line">   有了<span class="built_in">row</span> trx_id、事务的快照就是静态的了...</span><br></pre></td></tr></table></figure>

<p>假设:</p>
<ol>
<li>事务开启前、系统只有一个活跃事务id 99</li>
<li>事务A、B、C的版本号 100、101、102 且当前系统只有这4个事务</li>
<li>事务开始前、(1,1)这行数据的 row trx_id是90</li>
</ol>
<p>事务查询逻辑图:<br><img src="https://upload-images.jianshu.io/upload_images/14027542-7602ef99ebe62a71.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/340" alt="image.png"></p>
<p>所以、事务A的查询流程:</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. 找到(1,3) 判断<span class="attribute">trx_od</span>=101 比高水位大、处于红色区域、不可见</span><br><span class="line">2. 找到上个版本、row <span class="attribute">trx_id</span>=102 比高水位大、处于红色区域、不可见</span><br><span class="line">3. 继续、找到(1,1) row <span class="attribute">trx_id</span>=90、比低水位小、处于绿色区域、可见</span><br><span class="line"></span><br><span class="line">虽然这行数据被修改过、但事务A无论在何时查询、结果都是一致的、称为一致性读</span><br></pre></td></tr></table></figure>

<h4 id="更新逻辑"><a href="#更新逻辑" class="headerlink" title="更新逻辑"></a>更新逻辑</h4><p>那么是不是有个疑问:<br>按照一致性读、好像 事务B的update语句、是不对的 ？</p>
<p><img src="https://upload-images.jianshu.io/upload_images/14027542-9c0c0ec70b636639.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/240" alt="image.png"></p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">B进行<span class="keyword">update</span>时、是不是看不到(<span class="number">1</span>,<span class="number">2</span>)？怎么计算出来的(<span class="number">1</span>,<span class="number">3</span>) ？</span><br><span class="line"></span><br><span class="line">是的: 如果在事务B更新之前查询一次数据、会发现、返回的 k 的确是<span class="number">1</span></span><br><span class="line">但是更新数据的时候、就不能再历史版本上更新了、否则、事务C的更新就丢失了</span><br><span class="line">so. 事务B此时的更新是在(<span class="number">1</span>,<span class="number">2</span>) 的基础上进行的操作</span><br><span class="line"></span><br><span class="line">规则:</span><br><span class="line">更新都是先读后写的、这个读是当前读(<span class="keyword">current</span> <span class="keyword">read</span>)、只能读当前的值</span><br><span class="line"></span><br><span class="line">其实、除了<span class="keyword">update</span>、若<span class="keyword">select</span>加锁、也是当前读</span><br><span class="line"></span><br><span class="line">mysql&gt; <span class="keyword">select</span> k <span class="keyword">from</span> t <span class="keyword">where</span> id=<span class="number">1</span> <span class="keyword">lock</span> <span class="keyword">in</span> <span class="keyword">share mode</span>; // 读锁(S锁、共享锁)</span><br><span class="line">mysql&gt; <span class="keyword">select</span> k <span class="keyword">from</span> t <span class="keyword">where</span> id=<span class="number">1</span> <span class="keyword">for</span> <span class="keyword">update</span>; // 写锁(X锁、排他锁)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>再往前一步：<br>若 C不是马上提交的、而是事务C’ 会如何？</p>
<p><img src="https://upload-images.jianshu.io/upload_images/14027542-11fddfc9015b0955.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/340" alt="image.png"></p>
<figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">事务 c<span class="string">&#x27; 不同的是、未马上提交、在它提交前、事务B的更新发起、而此时 C&#x27;</span> 未提交、但是<span class="comment">(1,2)</span>这个版本也生成了、并且是当前最新版本</span><br><span class="line">那么B如何处理？</span><br><span class="line"></span><br><span class="line">此时就要考虑 两阶段锁协议、事务C<span class="string">&#x27;未提交、则写锁未释放、事务B是当前读、必须读最新版本、且必须加锁、</span></span><br><span class="line"><span class="string">则B被阻塞、必须等到C&#x27;</span>释放、才可继续</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>Q: 为何表结构不支持 可重复读?</p>
<figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">表结构无对应的数据行、也没有 <span class="built_in">row</span> trx_id 所以、只能遵循当前读</span><br></pre></td></tr></table></figure>

<p>Q: 使用如下表结构和初始化语句作为实验环境、事务隔离级别是可重复读、想把 字段 c和id 等值的行 的c值清零、发现 并未改掉<br>解释这种情况出现的场景及原理, 及如何避免？</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> `t`(</span><br><span class="line">`id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">not</span> <span class="keyword">null</span> ,</span><br><span class="line">`c` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">default</span> <span class="keyword">null</span> ,</span><br><span class="line"><span class="keyword">primary</span> key (`id`)</span><br><span class="line">)engine<span class="operator">=</span>innodb</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t(id, c) <span class="keyword">values</span> (<span class="number">1</span>,<span class="number">1</span>), (<span class="number">2</span>,<span class="number">2</span>), (<span class="number">3</span>, <span class="number">3</span>), (<span class="number">4</span>, <span class="number">4</span>);</span><br></pre></td></tr></table></figure>
<p>A: 场景一</p>
<figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">会话A</span><br><span class="line">mysql&gt; begin;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line"><span class="section">mysql&gt; select * from t;</span></span><br><span class="line"><span class="section">+----+------+</span></span><br><span class="line"><span class="section">| id | c    |</span></span><br><span class="line"><span class="section">+----+------+</span></span><br><span class="line">|  1 |    1 |</span><br><span class="line">|  2 |    2 |</span><br><span class="line">|  3 |    3 |</span><br><span class="line"><span class="section">|  4 |    4 |</span></span><br><span class="line"><span class="section">+----+------+</span></span><br><span class="line">4 rows in set (0.01 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; update t set c=0 whete id=c;</span><br><span class="line"></span><br><span class="line">会话B</span><br><span class="line">mysql&gt; update t set c=c+1;</span><br><span class="line">Query OK, 4 rows affected (0.01 sec)</span><br><span class="line">Rows matched: 4  Changed: 4  Warnings: 0</span><br><span class="line"></span><br><span class="line">会话A</span><br><span class="line"><span class="section">mysql&gt; select * from t;</span></span><br><span class="line"><span class="section">+----+------+</span></span><br><span class="line"><span class="section">| id | c    |</span></span><br><span class="line"><span class="section">+----+------+</span></span><br><span class="line">|  1 |    1 |</span><br><span class="line">|  2 |    2 |</span><br><span class="line">|  3 |    3 |</span><br><span class="line"><span class="section">|  4 |    4 |</span></span><br><span class="line"><span class="section">+----+------+</span></span><br><span class="line">4 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">会话A</span><br><span class="line">mysql&gt; commit;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line"><span class="section">mysql&gt; select * from t;</span></span><br><span class="line"><span class="section">+----+------+</span></span><br><span class="line"><span class="section">| id | c    |</span></span><br><span class="line"><span class="section">+----+------+</span></span><br><span class="line">|  1 |    2 |</span><br><span class="line">|  2 |    3 |</span><br><span class="line">|  3 |    4 |</span><br><span class="line"><span class="section">|  4 |    5 |</span></span><br><span class="line"><span class="section">+----+------+</span></span><br><span class="line">4 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>
<p>即：<br><img src="https://upload-images.jianshu.io/upload_images/14027542-eae83ec8f3ccedc4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/240" alt="image.png"></p>
<p>场景二：<br><img src="https://upload-images.jianshu.io/upload_images/14027542-7b63a20e1a0be038.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/240" alt="image.png"></p>
<p><strong>记住:update时、为当前读 current read</strong></p>
<h4 id="幻读"><a href="#幻读" class="headerlink" title="幻读"></a>幻读</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">1.</span> 在 可重复读 RR 隔离级别下、普通的查询是快照读、是不会看到别的事务插入数据的、</span><br><span class="line">   因此 幻读是在 当前读 下才会发生</span><br><span class="line"><span class="bullet">2.</span> 数据被修改、在当前读可以看到修改后的结果、这个不叫幻读、</span><br><span class="line">   幻读 专指 新插入的行被当前读读到</span><br></pre></td></tr></table></figure>

<h4 id="间隙锁-gaps-lock"><a href="#间隙锁-gaps-lock" class="headerlink" title="间隙锁-gaps lock"></a>间隙锁-gaps lock</h4><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">间隙锁: 锁的是两个值之间的空隙</span></span><br><span class="line"><span class="section">跟间隙锁存在冲突关系的是: 往这个间隙插入记录、间隙锁之间不存在冲突关系</span></span><br><span class="line"> </span><br><span class="line"><span class="section">行锁冲突关系: 读-读: no 读-写:no 写写: yes</span></span><br><span class="line"><span class="section">即: 跟间隙锁存在冲突关系的、是另外一个行锁</span></span><br><span class="line"></span><br><span class="line">间隙锁的引入会导致同样的语句锁住更大的范围、影响并发</span><br><span class="line">间隙锁只有在RR的隔离级别下才会生效、</span><br><span class="line"></span><br><span class="line">把隔离级别设为读提交的话、就没有间隙锁了、但是、要解决可能出现的数据和日志不一致的问题、</span><br><span class="line">需要把binlog的格式设置为row</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/03/20/mysql_mysql%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="niuniu">
      <meta itemprop="description" content="多数是学习笔记、偶尔发发感慨、给生活添加些许乐趣">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="牛牛的小窝">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/20/mysql_mysql%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/" class="post-title-link" itemprop="url">mysql常用命令</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-03-20 00:00:00" itemprop="dateCreated datePublished" datetime="2020-03-20T00:00:00+08:00">2020-03-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-05-07 11:31:06" itemprop="dateModified" datetime="2022-05-07T11:31:06+08:00">2022-05-07</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/MySQL/" itemprop="url" rel="index"><span itemprop="name">MySQL</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="lock"><a href="#lock" class="headerlink" title="lock"></a>lock</h4><ol>
<li>查看事务隔离级别</li>
</ol>
<blockquote>
<p>select @@transaction_isolation;</p>
</blockquote>
<ol start="2">
<li>设置全局事务(影响新的会话、不影响本会话)</li>
</ol>
<blockquote>
<p>set global transaction isolation level read committed; </p>
</blockquote>
<ol start="3">
<li>设置会话事务(影响本会话)</li>
</ol>
<blockquote>
<p>set session transaction isolation level read committed; </p>
</blockquote>
<ol start="4">
<li>查看mysql默认读取的 my.cnf 的命令</li>
</ol>
<blockquote>
<p>mysql –help | grep ‘my.cnf’</p>
</blockquote>
<p>查看mysql是否使用了指定目录的 my.cnf </p>
<blockquote>
<p>ps aux | grep ‘my.cnf’</p>
</blockquote>
<ol start="4">
<li><p>查看mysqlbinlog</p>
<blockquote>
<p>mysqlbinlog –no-defaults  &#x2F;var&#x2F;lib&#x2F;mysql&#x2F;mysqld-bin.000001 –start-position&#x3D;2425</p>
</blockquote>
</li>
<li><p>查看binlog的位置</p>
<blockquote>
<p>show variables like ‘%log_bin%’;</p>
</blockquote>
</li>
</ol>
<p> 开启binlog<br>  <figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server-id</span>=<span class="number">1</span></span><br><span class="line"><span class="attr">log_bin</span>=<span class="literal">ON</span></span><br><span class="line"><span class="attr">log_bin_basename</span>=/var/lib/mysql/mysql-bin</span><br><span class="line"><span class="attr">log_bin_index</span>=/var/lib/mysql/mysql-bin.index</span><br></pre></td></tr></table></figure></p>
<p>   查看所有的binlog文件</p>
<blockquote>
<p>show binary logs;</p>
</blockquote>
<p>   查看指定binlog文件的内存</p>
<blockquote>
<p>show binlog events in ‘{name}’;</p>
</blockquote>
<p>   当前日志的文件名和偏移位置</p>
<blockquote>
<p>show master status;</p>
</blockquote>
<p>   刷新日志文件</p>
<blockquote>
<p>flush logs;</p>
</blockquote>
<p>   查看死锁配置</p>
<blockquote>
<p>show variables like ‘%deadlock%’</p>
</blockquote>
<ol start="6">
<li><p>mysqlbinlog工具查看<br>基于时间: </p>
<blockquote>
<p>mysqlbinlog –start-datetime&#x3D;’2019-05-19 13:00’ –stop-datetime&#x3D;’2019-05-19 14:00’</p>
</blockquote>
<p>基于偏移量</p>
<blockquote>
<p>mysqlbinlog –start-postion&#x3D;107 –stop-position&#x3D;1000 -d {db} {binlog}</p>
</blockquote>
<p>row格式文件的查看 添加<code>-vv</code>参数</p>
</li>
<li><p>开启一致性视图</p>
<blockquote>
<p>start transaction with consistent snapshot;</p>
</blockquote>
</li>
<li><p>查看innodb页大小</p>
<blockquote>
<p>show global status like ‘innodb_page_size’;<br>show variables like ‘innodb_page_size’;</p>
</blockquote>
</li>
<li><p>查看表基本信息</p>
</li>
</ol>
<blockquote>
<p>select * from information_schema.tables where TABLE_NAME like ‘car_order_finished_collect_2019’;</p>
</blockquote>
<ol start="10">
<li>开启profile</li>
</ol>
<blockquote>
<p> show variables like ‘profiling’; set profiling&#x3D;1;</p>
</blockquote>
<ol start="11">
<li>显示所有的profile</li>
</ol>
<blockquote>
<p>show profiles;</p>
</blockquote>
<ol start="12">
<li><p>显示第n个profile的详情</p>
<blockquote>
<p>show profile for query n;<br>show profile all for query n; </p>
</blockquote>
</li>
<li><p>查看innodb redo log配置</p>
<blockquote>
<p>show variables like ‘%innodb_log_file%’;<br>   innodb_log_file_size 单个redo log大小、<br>   innodb_log_files_in_group redo log文件数量</p>
</blockquote>
</li>
<li><p>查看innodb io控制</p>
</li>
</ol>
<blockquote>
<p>show variables like ‘innodb_io_capacity’</p>
</blockquote>
<ol start="15">
<li>innodb脏页比例</li>
</ol>
<blockquote>
<p>show variables like ‘innodb_max_dirty_pages_pct’</p>
</blockquote>
<ol start="16">
<li>计算innodb当前脏页比例<blockquote>
<p> show global status like ‘Innodb_buffer_pool_pages_%’;<br>   Innodb_buffer_pool_pages_dirty&#x2F;Innodb_buffer_pool_pages_total</p>
</blockquote>
</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/03/20/mysql_mysql%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="niuniu">
      <meta itemprop="description" content="多数是学习笔记、偶尔发发感慨、给生活添加些许乐趣">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="牛牛的小窝">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/20/mysql_mysql%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">mysql笔记</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-03-20 00:00:00" itemprop="dateCreated datePublished" datetime="2020-03-20T00:00:00+08:00">2020-03-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-05-07 11:31:06" itemprop="dateModified" datetime="2022-05-07T11:31:06+08:00">2022-05-07</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/MySQL/" itemprop="url" rel="index"><span itemprop="name">MySQL</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>感谢林老师的mysql实战45讲<br><a target="_blank" rel="noopener" href="https://time.geekbang.org/column/intro/139">https://time.geekbang.org/column/intro/139</a><br><img src="http://upload-images.jianshu.io/upload_images/14027542-227879153c0c3275.jpg" alt="图片发自简书App"></p>
<p>希望老师越来越好、也希望自己能学得一二~</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/03/20/mysql_mysql%E7%B4%A2%E5%BC%95%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98%E6%95%B4%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="niuniu">
      <meta itemprop="description" content="多数是学习笔记、偶尔发发感慨、给生活添加些许乐趣">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="牛牛的小窝">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/20/mysql_mysql%E7%B4%A2%E5%BC%95%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98%E6%95%B4%E7%90%86/" class="post-title-link" itemprop="url">mysql索引相关问题整理</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-03-20 00:00:00" itemprop="dateCreated datePublished" datetime="2020-03-20T00:00:00+08:00">2020-03-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-05-07 11:31:06" itemprop="dateModified" datetime="2022-05-07T11:31:06+08:00">2022-05-07</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/MySQL/" itemprop="url" rel="index"><span itemprop="name">MySQL</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="count-1-count-count-id"><a href="#count-1-count-count-id" class="headerlink" title="count(1) count(*) count(id)"></a>count(1) count(*) count(id)</h4><blockquote>
<p>mysiam:<br>将表的总行数保存到了磁盘上、所以对于无条件的count(*) 是很快返回的</p>
</blockquote>
<blockquote>
<p>innodb实现：<br>count(*) 是把数据记录一行行的拿出来判断、<br>(innodb是索引组织表、主键索引的叶子节点是数据记录、普通索引的叶子节点是主键值、会小很多、mysql会选择最小的那颗索引树来遍历、在保证逻辑正确的情况下、尽量减少扫描的数据量)<br>count(1) 遍历表、但不取值、扫描记录时、返回1给server<br>count(id) 会把id返回给server<br>count(field)<br>若定义为非null、会先判断该字段记录是否为null、非null才累加<br>若定义为null、从记录读出字段、累加</p>
</blockquote>
<h4 id="为什么mysql不直接记录count数？"><a href="#为什么mysql不直接记录count数？" class="headerlink" title="为什么mysql不直接记录count数？"></a>为什么mysql不直接记录count数？</h4><blockquote>
<p>innodb要保证事务执行、不同会话、commit前后 总行数是会发生改变的</p>
</blockquote>
<h4 id="show-table-status-替代？"><a href="#show-table-status-替代？" class="headerlink" title="show table status 替代？"></a>show table status 替代？</h4><blockquote>
<p>得到的结果是通过采样估算得到的、不精准、最高偏差有40%-50%</p>
</blockquote>
<h4 id="采样缓存系统保存计数"><a href="#采样缓存系统保存计数" class="headerlink" title="采样缓存系统保存计数?"></a>采样缓存系统保存计数?</h4><blockquote>
<p>1.redis重启、数据丢失<br>2.redis和db本身记录增加先后的问题会导致短时间的不精准</p>
</blockquote>
<h4 id="使用mysql表保存总记录？"><a href="#使用mysql表保存总记录？" class="headerlink" title="使用mysql表保存总记录？"></a>使用mysql表保存总记录？</h4><blockquote>
<p>可以、使用mysql的事务来保证、但是会影响性能</p>
</blockquote>
<p>mysql两阶段提交的过程：<br><img src="https://upload-images.jianshu.io/upload_images/14027542-0f3b96cc0f6f0519.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/340" alt="image.png"></p>
<h4 id="在不同阶段crash对于系统的影响"><a href="#在不同阶段crash对于系统的影响" class="headerlink" title="在不同阶段crash对于系统的影响"></a>在不同阶段crash对于系统的影响</h4><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 图中A时刻(<span class="keyword">redo</span> <span class="keyword">log</span>写完、binlog还没写的时候)crash、binlog还没写、<span class="keyword">redo</span> <span class="keyword">log</span>也没提交、重启事务会回滚~</span><br><span class="line"><span class="number">2.</span>若是在B、binlog写完、<span class="keyword">redo</span> <span class="keyword">log</span>还未commit时、crash会发生什么？</span><br><span class="line">   a. 若<span class="keyword">redo</span> <span class="keyword">log</span>也是完整的-有了commit标识、直接提交</span><br><span class="line">   b. 若<span class="keyword">redo</span> <span class="keyword">log</span>只有完整的prepare、则判断对应的binlog是否完整、</span><br><span class="line">      完整-提交事务; 否则: 回滚事务</span><br></pre></td></tr></table></figure>

<h4 id="mysql如何知道binlog是完整的？"><a href="#mysql如何知道binlog是完整的？" class="headerlink" title="mysql如何知道binlog是完整的？"></a>mysql如何知道binlog是完整的？</h4><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">一个事务的binlog有完整的格式:</span></span><br><span class="line"><span class="section">statement格式的: 最后会有commit</span></span><br><span class="line"><span class="section">row格式的: 最后会有Xid event</span></span><br><span class="line">MySQL5.6.2 之后、还引入了checksum检查日志中间出错的情况</span><br></pre></td></tr></table></figure>

<h4 id="redo-log和binlog是如何关联的"><a href="#redo-log和binlog是如何关联的" class="headerlink" title="redo log和binlog是如何关联的"></a>redo log和binlog是如何关联的</h4><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">有一个共同的字段XID、crash恢复的时候会按顺序扫描redo <span class="built_in">log</span>:</span><br><span class="line"><span class="number">1.</span> 遇到既有<span class="built_in">prepare</span> 又有commit的redo <span class="built_in">log</span>直接提交</span><br><span class="line"><span class="number">2.</span> 遇到只有<span class="built_in">prepare</span>的、就拿XID去对应的binlog查找事务</span><br></pre></td></tr></table></figure>

<h4 id="处于prepare阶段的redo-log-完整的binlog重启就能恢复、为什么这么设计"><a href="#处于prepare阶段的redo-log-完整的binlog重启就能恢复、为什么这么设计" class="headerlink" title="处于prepare阶段的redo log + 完整的binlog重启就能恢复、为什么这么设计?"></a>处于prepare阶段的redo log + 完整的binlog重启就能恢复、为什么这么设计?</h4><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在时刻B、binlog就已经被写入了、若是应用于从库、从库就有了这条记录、为了保证主从数据的一致性、就必须保证主库也有这条记录、所以把<span class="keyword">redo</span> <span class="keyword">log</span>提交</span><br></pre></td></tr></table></figure>

<h4 id="为什么不是先写完redo-log再写binlog-？"><a href="#为什么不是先写完redo-log再写binlog-？" class="headerlink" title="为什么不是先写完redo log再写binlog ？"></a>为什么不是先写完redo log再写binlog ？</h4><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">比较典型的分布式问题</span><br><span class="line">若<span class="keyword">redo</span> <span class="keyword">log</span>提交了、又不能回滚(回滚可能会覆盖掉其它的事务)、所以<span class="keyword">redo</span> <span class="keyword">log</span>直接提交、binlog写入失败的时候、由于不能回滚、就会比从库多一个事务</span><br></pre></td></tr></table></figure>

<h4 id="为什么不直接使用binlog、不用redo-log-？"><a href="#为什么不直接使用binlog、不用redo-log-？" class="headerlink" title="为什么不直接使用binlog、不用redo log ？"></a>为什么不直接使用binlog、不用redo log ？</h4><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">若是历史原因: innodb本身不是mysql的原生引擎、原生引擎是mysiam、不支持崩溃恢复</span><br><span class="line">innodb在加入mysql之前、就可以支持崩溃恢复和事务</span><br><span class="line">innodb发现<span class="keyword">binlog没有崩溃恢复的能力、那就直接使用redo </span>log吧、</span><br><span class="line">如果用<span class="keyword">binlog支持崩溃恢复呢 </span>？流程如下图</span><br><span class="line">在这样的流程下、<span class="keyword">binlog还是不能支持崩溃恢复、不能支持恢复数据页</span></span><br><span class="line"><span class="keyword"></span>若<span class="keyword">binlog2写完、未commit的时候crash、引擎内部事务2会回滚、应用binlog2可以补回来、但对于binlog1事务已经提交、不会再应用binlog1</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line">innodb使用的是WAL、在写完内存和日志的时候、事务就算完成了、若以后崩溃、依赖日志恢复数据页、图中<span class="number">1</span>位置crash 事务<span class="number">1</span>可能会丢失、且是数据页级的丢失、<span class="keyword">binlog未记录数据页的更新细节、不支持数据页恢复</span></span><br></pre></td></tr></table></figure>
<p><img src="https://upload-images.jianshu.io/upload_images/14027542-9b6ac9029bcb1485.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/340" alt="image.png"></p>
<h4 id="能只用redo-log不用binlog吗？"><a href="#能只用redo-log不用binlog吗？" class="headerlink" title="能只用redo log不用binlog吗？"></a>能只用redo log不用binlog吗？</h4><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 只从崩溃恢复的角度来讲、可以关掉binlog、系统依然是crash-safe的、但binlog有<span class="keyword">redo</span> <span class="keyword">log</span>不可替代的功能</span><br><span class="line">a. 归档. <span class="keyword">redo</span> <span class="keyword">log</span>是循环写、日志无法保留</span><br><span class="line">b. mysql系统依赖于binlog、binlog作为mysql本身就有的功能、</span><br><span class="line">c. 一些异构系统、需要消费binlog来更新数据</span><br></pre></td></tr></table></figure>

<h4 id="redo-log一般设置多大？"><a href="#redo-log一般设置多大？" class="headerlink" title="redo log一般设置多大？"></a>redo log一般设置多大？</h4><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redo <span class="built_in">log</span>过小、会导致很快写满、不得不强行刷盘、这样WAL的能力就发挥不出来了、若磁盘在<span class="built_in">T</span>级别、就直接设置为G级别吧~</span><br></pre></td></tr></table></figure>

<h4 id="正常运行的实例、数据写入后的最终落盘是从redo-log更新的还是从buffer-poll更新的？"><a href="#正常运行的实例、数据写入后的最终落盘是从redo-log更新的还是从buffer-poll更新的？" class="headerlink" title="正常运行的实例、数据写入后的最终落盘是从redo log更新的还是从buffer poll更新的？"></a>正常运行的实例、数据写入后的最终落盘是从redo log更新的还是从buffer poll更新的？</h4><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">redo</span> <span class="keyword">log</span> 并没有记录数据页的完整数据、所以本身没有能力更新磁盘数据页、</span><br><span class="line"><span class="number">1.</span> 数据页被修改后与磁盘数据页不一致、最终落盘就是把内存中的数据写入磁盘、与<span class="keyword">redo</span> <span class="keyword">log</span>无关</span><br><span class="line"><span class="number">2.</span> 崩溃恢复的场景中、innodb如果判断到一个数据页可能在崩溃恢复的时候丢失了更新就会将它读入内存、然后让<span class="keyword">redo</span> <span class="keyword">log</span>更新内存内容、更新完、内存变成脏页、回到<span class="number">1</span>的情况</span><br></pre></td></tr></table></figure>

<h4 id="redo-log-buffer是什么？是先修改内存、还是写写redo-log-？"><a href="#redo-log-buffer是什么？是先修改内存、还是写写redo-log-？" class="headerlink" title="redo log buffer是什么？是先修改内存、还是写写redo log ？"></a>redo log buffer是什么？是先修改内存、还是写写redo log ？</h4><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">在事务更新过程中 <span class="keyword">redo</span> <span class="keyword">log</span> 是要多次写的、</span><br><span class="line">eg. begin;</span><br><span class="line">      insert into t1...;</span><br><span class="line">      insert into t2...;</span><br><span class="line">     commit;</span><br><span class="line">这个事务要在两个表中插入记录、在插入的过程中、生成的日志都得先保存起来、但又不能在还没commit的时候写<span class="keyword">redo</span> <span class="keyword">log</span></span><br><span class="line"></span><br><span class="line">所以 <span class="keyword">redo</span> <span class="keyword">log</span> buffer就是一块内存、用来保存 <span class="keyword">redo</span> <span class="keyword">log</span>日志的. 即 在执行第一个insert的时候、数据的内存被修改了、<span class="keyword">redo</span> <span class="keyword">log</span> buffer也写入了日志</span><br><span class="line">但真正写入<span class="keyword">redo</span> <span class="keyword">log</span>(ib_logfile+日志)是在执行commit语句的时候做的、</span><br></pre></td></tr></table></figure>

<h4 id="update记录为原值的时候、mysql如何操作？"><a href="#update记录为原值的时候、mysql如何操作？" class="headerlink" title="update记录为原值的时候、mysql如何操作？"></a>update记录为原值的时候、mysql如何操作？</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">1.</span> update是先读后写、发现值本来就是原值、不操作、直接返回</span><br><span class="line"><span class="bullet">2.</span> mysql调用innodb引擎接口修改、引擎发现与原值相同、不更新、直接返回</span><br><span class="line"><span class="bullet">3.</span> innodb认真的执行了更新、改加锁的加锁?</span><br><span class="line"></span><br><span class="line">答案是3、可以通过事务来验证</span><br></pre></td></tr></table></figure>
<p>过程请参考: <a target="_blank" rel="noopener" href="https://time.geekbang.org/column/article/73479">https://time.geekbang.org/column/article/73479</a></p>
<p><strong>varchar(255)是边界、&gt;255需要两个字节存储、小于需要1个字节</strong></p>
<ol start="4">
<li><p>mysql 源码编译启动报错</p>
<figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">mysql启动报错：Starting MySQL... <span class="literal">ERROR</span>! The server quit without updating PID <span class="keyword">file</span></span><br><span class="line"></span><br><span class="line">看errlog 发现:</span><br><span class="line"><span class="number">2018</span>-<span class="number">01</span>-<span class="number">24</span> <span class="number">07</span>:<span class="number">57</span>:<span class="number">03</span> <span class="number">67547</span> [<span class="literal">ERROR</span>] Fatal <span class="literal">error</span>: Can<span class="symbol">&#x27;t</span> <span class="keyword">open</span> <span class="keyword">and</span> lock privilege tables: Table <span class="symbol">&#x27;mysql</span>.user&#x27; doesn<span class="symbol">&#x27;t</span> exist</span><br><span class="line"><span class="keyword">or</span>: <span class="number">2018</span>-<span class="number">01</span>-<span class="number">24</span> <span class="number">07</span>:<span class="number">57</span>:<span class="number">03</span> [<span class="literal">ERROR</span>]   Can<span class="symbol">&#x27;t</span> locate the language directory.</span><br><span class="line"></span><br><span class="line">重新初始化db:</span><br><span class="line">mysql_install_db <span class="comment">--user=mysql --basedir=/home/devil/mysql57/ --datadir=/home/devil/mysql57/data/</span></span><br><span class="line"></span><br><span class="line">出现:</span><br><span class="line"><span class="number">2019</span>-<span class="number">04</span>-<span class="number">18</span> <span class="number">21</span>:<span class="number">23</span>:<span class="number">16</span> [<span class="literal">WARNING</span>] mysql_install_db <span class="keyword">is</span> deprecated. Please consider switching <span class="keyword">to</span> mysqld <span class="comment">--initialize</span></span><br><span class="line"></span><br><span class="line">so. </span><br><span class="line">mysqld <span class="comment">--initialize --user=mysql --basedir=/home/devil/mysql57/ --datadir=/home/devil/mysql57/data/</span></span><br><span class="line"></span><br><span class="line">可以看到初始化成功. 并生成了临时密码</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>mysql binlog 查看</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">a. 登录mysql查看</span><br><span class="line">   1) 只查看第一个binlog文件的内容</span><br><span class="line">        show binlog events;</span><br><span class="line">   2) 查看指定binlog文件的内容</span><br><span class="line">        show binlog events <span class="keyword">in</span> <span class="string">&#x27;mysql-binlog.000001&#x27;</span>;</span><br><span class="line">   3) 查看当前正在写入的binlog</span><br><span class="line">        show master status;</span><br><span class="line">    4) 获取binlog文件列表</span><br><span class="line">        show binary logs;</span><br><span class="line"></span><br><span class="line"> b. 使用mysqlbinlog工具查看</span><br><span class="line">     1) 本地查看 </span><br><span class="line">         基于开始/结束时间: </span><br><span class="line">         mysqlbinlog <span class="attribute">--start-datatime</span>=<span class="string">&#x27;2019-04-10 00:00:00&#x27;</span> <span class="attribute">--stop-datatime</span>=<span class="string">&#x27;2019-04-10 01:00:00&#x27;</span>  </span><br><span class="line">         基于pos值</span><br><span class="line">         mysqlbinlog <span class="attribute">--start-postion</span>=107 <span class="attribute">--stop-position</span>=1000 -d 库名 二进制文件</span><br><span class="line"></span><br><span class="line">      2)  远程查看</span><br><span class="line">           mysqlbinlog -u&#123;uname&#125; -p&#123;pass&#125; -htest.com -P3306 \</span><br><span class="line">--read-from-remote-server <span class="attribute">--start-datetime</span>=<span class="string">&#x27;2013-09-10 23:00:00&#x27;</span> <span class="attribute">--stop-datetime</span>=<span class="string">&#x27;2013-09-10 23:30:00&#x27;</span> mysql-bin.000001 &gt; t.binlog</span><br></pre></td></tr></table></figure></li>
</ol>
<figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">set optimizer_trace=<span class="string">&#x27;enabled=on&#x27;</span> 打开<span class="keyword">trace</span>记录</span><br><span class="line"><span class="keyword">select</span>  <span class="keyword">trace</span> from   <span class="string">`information_schema`</span>.<span class="string">`optimizer_trace`</span>; 查看<span class="keyword">trace</span>记录</span><br><span class="line"></span><br><span class="line">tmp_table_size 内存临时表大小</span><br><span class="line">sort_buffer_size 用于排序的内存大小、超过会使用文件排序</span><br><span class="line">max_length_for_sort_data 单行数据量超过这个值会使用rowid排序</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">查看<span class="keyword">sql</span>被哪个语句阻塞</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t sys.innodb_lock_waits <span class="keyword">where</span> locked_table<span class="operator">=</span>`<span class="string">&#x27;test&#x27;</span>.<span class="string">&#x27;t&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> blocking_pid <span class="keyword">from</span> sys.schema_table_lock_waits 可以找到阻塞的pid</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/03/20/mysql_mysql%E7%B4%A2%E5%BC%95%E9%80%89%E6%8B%A9/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="niuniu">
      <meta itemprop="description" content="多数是学习笔记、偶尔发发感慨、给生活添加些许乐趣">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="牛牛的小窝">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/20/mysql_mysql%E7%B4%A2%E5%BC%95%E9%80%89%E6%8B%A9/" class="post-title-link" itemprop="url">mysql索引选择</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-03-20 00:00:00" itemprop="dateCreated datePublished" datetime="2020-03-20T00:00:00+08:00">2020-03-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-05-07 11:31:06" itemprop="dateModified" datetime="2022-05-07T11:31:06+08:00">2022-05-07</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/MySQL/" itemprop="url" rel="index"><span itemprop="name">MySQL</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="普通索引和唯一索引"><a href="#普通索引和唯一索引" class="headerlink" title="普通索引和唯一索引"></a>普通索引和唯一索引</h4><h5 id="场景："><a href="#场景：" class="headerlink" title="场景："></a>场景：</h5><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">假设维护一个市民系统、每个人有一个唯一的身份证号、经常会根据身份证号查询、<span class="keyword">sql</span>如下:</span><br><span class="line"><span class="keyword">select</span> <span class="type">name</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> id_card=<span class="string">&#x27;xxx&#x27;</span>;</span><br><span class="line">一定会考虑在id_card上建立索引、那么、这个索引应该是唯一索引还是普通索引呢 ？</span><br></pre></td></tr></table></figure>
<h5 id="思考"><a href="#思考" class="headerlink" title="思考:"></a>思考:</h5><blockquote>
<p>id_card字段比较大、不建议作为主键、那么、1.普通索引 2.唯一索引 如何选择？依据又是什么呢 ？</p>
</blockquote>
<p><img src="https://upload-images.jianshu.io/upload_images/14027542-a869a323d23b3991.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/340" alt="mysql索引结构组织树.png"></p>
<h5 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h5><p><strong>查询过程</strong></p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">假设执行的语句为 select t <span class="keyword">from</span> T where <span class="attribute">k</span>=5;</span><br><span class="line">搜索从根开始、按层搜索到叶子节点、可以认为数据页内部通过二分法来定位</span><br><span class="line">1. 对于普通索引、查找到第一条记录(5, 500) 之后、需要查找下一个记录、直到碰到第一个不满足<span class="attribute">k</span>=5的记录</span><br><span class="line">2. 对于唯一索引】由于定义了唯一性、查找到(5, 500) 之后、停止检索、直接返回</span><br><span class="line">那么带来的性能差异呢 ？ - 微乎其微</span><br><span class="line"></span><br><span class="line">innodb的数据是按照数据页为单位来读写的、即: 当需要读一条记录的时候、不是讲记录本身从磁盘读出、而是以页为单位、</span><br><span class="line">将整个数据页读取到内存、数据页大小默认为16k</span><br><span class="line"></span><br><span class="line">因为是按页读取、当找到<span class="attribute">k</span>=5时、它所在的数据页已经在内存了、对于普通索引来说、多做的一次&#x27;查找和判断下一条记录&#x27;只需要一次指针查找和一次计算</span><br><span class="line">不幸的是、恰好<span class="attribute">l</span>=5是数据页的最后一条记录呢 ？<span class="built_in">..</span><span class="built_in">..</span></span><br><span class="line">必须读取下一个数据页, 对于整型字段、16k可以放近千个key、出现这种情况的概率很低、所以计算平均性能差异时、可认为这个操作成本对于现在的CPU来说可以忽略不计</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>更新过程</strong></p>
<h5 id="change-buffer"><a href="#change-buffer" class="headerlink" title="change_buffer"></a>change_buffer</h5><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">先说下change<span class="emphasis">_buffer的概念：</span></span><br><span class="line"><span class="emphasis">更新数据页时，若数据页在内存中 -&gt; 直接更新，</span></span><br><span class="line"><span class="emphasis">不在内存 -&gt; 在不影响一致性读的情况下、会讲更新操作缓存在change_</span>buffer</span><br><span class="line">这样就不需要从磁盘读入数据页, 下次查询需要访问这个数据页时、将数据页读到内存、与change<span class="emphasis">_buffer合并(称为merge)</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">虽然名字叫change_</span>buffer、实际可持久化、在内存中有copy、也会被写入磁盘</span><br><span class="line"></span><br><span class="line">触发merge:</span><br><span class="line"><span class="bullet">1.</span> 访问数据页</span><br><span class="line"><span class="bullet">2.</span> 后台线程定期merge</span><br><span class="line"><span class="bullet">3.</span> db正常关闭、shutdown</span><br><span class="line"><span class="bullet">4.</span> 达到change<span class="emphasis">_buffer的可用最大内存、触发merge、然后淘汰</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">显然、如果更新操作先记录在change_</span>buffer、减少读磁盘、可以提高sql执行效率</span><br><span class="line">而且、数据读入内存、是需要占用buffer<span class="emphasis">_pool的、这种方式还可以避免占用内存、提高内存使用效率</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">那么什么时候可以使用buffer_</span>pool?</span><br><span class="line"><span class="bullet">1.</span> change<span class="emphasis">_buffer 占用 buffer_</span>pool 的内存、通过 innodb<span class="emphasis">_change_</span>buffer<span class="emphasis">_max_</span>size 调整、设为50、</span><br><span class="line">   表示change<span class="emphasis">_buffer 最多占用buffer_</span>pool的50%</span><br><span class="line"><span class="bullet">2.</span> 不能无限增大、不能 &gt; buffer<span class="emphasis">_pool</span></span><br><span class="line"><span class="emphasis">3. 对唯一索引来说、所有的更新都要判断操作是否违反唯一约束、</span></span><br><span class="line"><span class="emphasis">   eg. 要插入(4, 400)这个记录、必须先判断记录是否存在、必须先将数据页读入内存</span></span><br><span class="line"><span class="emphasis">   若已读入内存、直接更新内存更快、无需使用 change_</span>buffer、</span><br><span class="line">   实际上、唯一索引的更新也不能使用change<span class="emphasis">_buffer、只有普通索引可用</span></span><br></pre></td></tr></table></figure>

<h5 id="理解了-change-buffer、看下插入-4，400"><a href="#理解了-change-buffer、看下插入-4，400" class="headerlink" title="理解了 change_buffer、看下插入(4，400)"></a>理解了 change_buffer、看下插入(4，400)</h5><figure class="highlight nestedtext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">1. 更新的记录目标页在内存 - 无差别(只有一个判断的差别)</span></span><br><span class="line"><span class="attribute">   1) 唯一索引</span><span class="punctuation">:</span> <span class="string">找到3、5之间位置、判断无冲突、直接插入</span></span><br><span class="line">   <span class="attribute">2) 普通索引</span><span class="punctuation">:</span> <span class="string">找到3、5之间、直接插入</span></span><br><span class="line"></span><br><span class="line"><span class="attribute">2. 更新记录目标页不在内存</span></span><br><span class="line"><span class="attribute">   1) 唯一索引</span><span class="punctuation">:</span> <span class="string">将数据页读入内存、判断无冲突、插入</span></span><br><span class="line">   <span class="attribute">2) 普通索引</span><span class="punctuation">:</span> <span class="string">将记录更新在change_buffer、执行结束</span></span><br><span class="line">   <span class="attribute">将数据从磁盘读到内存、涉及io随机访问、change_buffer减少了随意访问磁盘、性能会明显提升</span></span><br><span class="line"><span class="attribute">   </span></span><br><span class="line"><span class="attribute">3. 案例：</span></span><br><span class="line"><span class="attribute">   业务库的内存命中率突然下降、整个系统处于阻塞状态、更新全部阻塞、</span></span><br><span class="line"><span class="attribute">   深入排查后发现</span><span class="punctuation">:</span> <span class="string">业务有大量的插入操作、而、前一天晚上上、将普通索引改成了唯一索引、使写操作的效率下降</span></span><br></pre></td></tr></table></figure>

<h5 id="change-buffer使用场景"><a href="#change-buffer使用场景" class="headerlink" title="change_buffer使用场景"></a>change_buffer使用场景</h5><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">change_buffer对于查询无明显效果、也只适用于普通索引、那么 普通索引的所有场景、change_buffer都能起到加速作用么 ？</span><br><span class="line"></span><br><span class="line">1. <span class="keyword">merge</span> 的时候是真正数据更新的时刻、change_buffer主要是将记录变更的动作缓存、<span class="keyword">so</span>.<span class="keyword">merge</span>前变更越多、收益越大</span><br><span class="line">   对于写多、读少的业务、change_buffer的效果最好、常见业务模型: 账单类、日志类系统</span><br><span class="line">   </span><br><span class="line">2. 若业务场景是、写完立马会有查询、由于立马访问数据页、会立即触发<span class="keyword">merge</span>、随机访问的io次数不会减少、</span><br><span class="line">  反而增加了change_buffer的维护代价、不适合使用</span><br></pre></td></tr></table></figure>

<h5 id="索引选择和实践"><a href="#索引选择和实践" class="headerlink" title="索引选择和实践"></a>索引选择和实践</h5><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1. 若所有更新后跟着记录的查询、应关闭change<span class="emphasis">_buffer</span></span><br><span class="line"><span class="emphasis">2. 若有一个机械硬盘的历史库、应尽量使用普通索引、调大change_</span>buffer、确保历史数据的写入效率</span><br></pre></td></tr></table></figure>

<h5 id="change-buffer-和-redo-log"><a href="#change-buffer-和-redo-log" class="headerlink" title="change_buffer 和 redo log"></a>change_buffer 和 redo log</h5><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">假设执行更新</span><br><span class="line">insert into <span class="built_in">t</span>(id, k) <span class="built_in">values</span>(id1, k1), (id2, k2)</span><br><span class="line">当前k索引树的状态、k1所在的数据页在内存(innodb buffer pool)中、</span><br></pre></td></tr></table></figure>

<p><img src="https://upload-images.jianshu.io/upload_images/14027542-0d07c7e2f5c7640c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/240" alt="带change_buffer的数据更新.png"></p>
<figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">涉及: 内存、<span class="function"><span class="title">redolog</span>(<span class="variable">ib_log_fileX</span>)、数据表空间(<span class="variable">t.ibd</span>)、系统表空间(<span class="variable">ibdata1</span>) 四个部分</span></span><br><span class="line"><span class="function">更新做了如下操作:</span></span><br><span class="line"><span class="function"><span class="number">1</span>. page1在内存、直接更新内存 (图中<span class="number">1</span>)</span></span><br><span class="line"><span class="number">2</span>. page2不在内存、在内存的<span class="variable">change_buffer</span>区域、记录下 <span class="string">&#x27;往page2插入1行&#x27;</span> 这个信息 (图中<span class="number">2</span>)</span><br><span class="line"><span class="number">3</span>. 将<span class="number">1</span>、<span class="number">2</span>两个动作写入<span class="variable">redo</span> <span class="function"><span class="title">log</span>(图中<span class="number">3</span>、<span class="number">4</span>)</span></span><br><span class="line"></span><br><span class="line">所以、这条更新写了两处内存、一次磁盘(两次操作合写一次磁盘)还是顺序写、</span><br><span class="line"></span><br><span class="line">图中两个虚线、是后台操作、不影响更新的响应时间</span><br></pre></td></tr></table></figure>

<p><strong>读请求</strong><br><img src="https://upload-images.jianshu.io/upload_images/14027542-ae14a2d3a50f1d8c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/240" alt="带change_buffer的读.png"></p>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">select * from t where <span class="keyword">k</span> in (k1, k2)</span><br><span class="line"></span><br><span class="line"><span class="number">1</span>. 假设、读发生在更新不久、内存中数据还在、此时与系统表空间和redolog无关、直接读即可</span><br><span class="line"><span class="number">2</span>. 读page1时、从内存返回、读page2时、需要把page2从磁盘读入内存、然后应用<span class="keyword">change</span> <span class="keyword">buffer</span>的操作日志、合并数据</span><br><span class="line"></span><br><span class="line"><span class="keyword">so</span>. 简单对比这两个机制在提升更新性能上的收益的话、</span><br><span class="line"><span class="keyword">redo</span> <span class="built_in">log</span>节省的是随机写 IO 的消耗、转为顺序写</span><br><span class="line"><span class="keyword">change</span> <span class="keyword">buffer</span>节省的是随机读io的消耗</span><br></pre></td></tr></table></figure>

<p>Q: change_buffer一开始是写内存的、此时若掉电重启、会导致change_buffer丢失么 ？ 若丢失、从磁盘读入时、就丢了merge、相当于丢了数据…</p>
<p>A:</p>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">虽然只是更新内存、但: 事务提交时、把<span class="keyword">change</span> <span class="keyword">buffer</span>的操作记录到了 <span class="keyword">redo</span> <span class="built_in">log</span>. 所以恢复时、<span class="keyword">change</span> <span class="keyword">buffer</span>可以找回</span><br><span class="line"></span><br><span class="line"><span class="number">1</span>.<span class="keyword">change</span> <span class="keyword">buffer</span>有一部分在内存有一部分在ibdata.</span><br><span class="line">做purge操作,应该就会把<span class="keyword">change</span> <span class="keyword">buffer</span>里相应的数据持久化到ibdata</span><br><span class="line"><span class="number">2</span>.<span class="keyword">redo</span> <span class="built_in">log</span>里记录了数据页的修改以及<span class="keyword">change</span> <span class="keyword">buffer</span>新写入的信息</span><br><span class="line">如果掉电,持久化的<span class="keyword">change</span> <span class="keyword">buffer</span>数据已经purge,不用恢复。主要分析没有持久化的数据</span><br><span class="line">情况又分为以下几种:</span><br><span class="line">(<span class="number">1</span>)<span class="keyword">change</span> <span class="keyword">buffer</span>写入,<span class="keyword">redo</span> <span class="built_in">log</span>虽然做了fsync但未commit,binlog未fsync到磁盘,这部分数据丢失</span><br><span class="line">(<span class="number">2</span>)<span class="keyword">change</span> <span class="keyword">buffer</span>写入,<span class="keyword">redo</span> <span class="built_in">log</span>写入但没有commit,binlog以及fsync到磁盘,先从binlog恢复<span class="keyword">redo</span> <span class="built_in">log</span>,再从<span class="keyword">redo</span> <span class="built_in">log</span>恢复<span class="keyword">change</span> <span class="keyword">buffer</span></span><br><span class="line">(<span class="number">3</span>)<span class="keyword">change</span> <span class="keyword">buffer</span>写入,<span class="keyword">redo</span> <span class="built_in">log</span>和binlog都已经fsync.那么直接从<span class="keyword">redo</span> <span class="built_in">log</span>里恢复</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">merge流程：</span><br><span class="line"><span class="number">1</span>. 从磁盘读入数据页到内存</span><br><span class="line"><span class="number">2</span>. 从<span class="keyword">change</span> <span class="keyword">buffer</span>找出这个数据页的<span class="keyword">change</span> <span class="keyword">buffer</span>记录(可能是多个)、依次应用、得到新版数据页</span><br><span class="line"><span class="number">3</span>. 写<span class="keyword">redo</span> <span class="built_in">log</span>. 这个<span class="keyword">redo</span> <span class="built_in">log</span>包含了数据的变更和<span class="keyword">change</span> <span class="keyword">buffer</span>的变更</span><br><span class="line">merge流程完成、哈哈、此时 数据页和内存中<span class="keyword">change</span> <span class="keyword">buffer</span>对应的磁盘位置都还没修改、属于脏页、之后各自刷回自己的物理数据 -&gt; 另外一个流程</span><br></pre></td></tr></table></figure>

<h5 id=""><a href="#" class="headerlink" title=""></a></h5><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">内存命中率: ib_bp_hit=<span class="number">1000</span> – (t2.iReads – t1.iReads)/(t2.iReadRequest – t1.iReadRequest)*<span class="number">1000</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">change</span> <span class="keyword">buffer</span>相当于推迟更新、对于MVCC是否有影响?比如加锁？</span><br><span class="line">锁是单独的数据结构、若数据页上有锁、<span class="keyword">change</span> <span class="keyword">buffer</span>在判断能否使用时、会认为否</span><br><span class="line"></span><br><span class="line"><span class="keyword">change</span> <span class="keyword">buffer</span>中、有此行记录的条件下、再次修改、是增加还是原地修改?</span><br><span class="line">增加</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/03/20/mysql_mysql%E9%94%81/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="niuniu">
      <meta itemprop="description" content="多数是学习笔记、偶尔发发感慨、给生活添加些许乐趣">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="牛牛的小窝">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/20/mysql_mysql%E9%94%81/" class="post-title-link" itemprop="url">mysql锁</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-03-20 00:00:00" itemprop="dateCreated datePublished" datetime="2020-03-20T00:00:00+08:00">2020-03-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-05-07 11:31:06" itemprop="dateModified" datetime="2022-05-07T11:31:06+08:00">2022-05-07</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/MySQL/" itemprop="url" rel="index"><span itemprop="name">MySQL</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="锁的种类和概念"><a href="#锁的种类和概念" class="headerlink" title="锁的种类和概念"></a>锁的种类和概念</h3><p><em>Shared and Exclusive Locks</em></p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Shard <span class="keyword">Lock</span>: 共享锁</span><br><span class="line">官方: permits the <span class="keyword">transaction</span> that holds the <span class="keyword">lock</span> <span class="keyword">to</span> <span class="keyword">read</span> a <span class="keyword">row</span>.</span><br><span class="line">eg. <span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> id=<span class="number">1</span> <span class="keyword">lock</span> <span class="keyword">in</span> <span class="keyword">share mode</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">Exclusive</span> Locks: 排他锁</span><br><span class="line">官方: permits the <span class="keyword">transaction</span> that holds the <span class="keyword">lock</span> <span class="keyword">to</span> <span class="keyword">update</span> <span class="keyword">or</span> <span class="keyword">delete</span> a <span class="keyword">row</span></span><br><span class="line">eg. <span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> id=<span class="number">1</span> <span class="keyword">for</span> <span class="keyword">update</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><em>Intention Locks</em></p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">锁是加在<span class="keyword">table</span>上的、表示要对下一个层级(记录)加锁</span><br><span class="line">Intention shared(<span class="keyword">IS</span>): <span class="keyword">Transaction</span> T intends <span class="keyword">to</span> <span class="keyword">set</span> S locks <span class="keyword">on</span> individual <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">table</span> t</span><br><span class="line">Intention <span class="keyword">exclusive</span>(IX): <span class="keyword">Transaction</span> T intends <span class="keyword">to</span> <span class="keyword">set</span> X <span class="keyword">lock</span> <span class="keyword">on</span> those <span class="keyword">rows</span></span><br><span class="line">在db层看到的是：</span><br><span class="line"><span class="keyword">Table</span> <span class="keyword">Lock</span> <span class="keyword">table</span> `db`.`<span class="keyword">table</span>` trx_id <span class="number">12121212</span> <span class="keyword">lock</span> mode IX</span><br></pre></td></tr></table></figure>

<p><em>Record Locks</em></p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">在db层看到的是:</span><br><span class="line"><span class="type">Record</span> Locks space id <span class="keyword">in</span> <span class="number">281</span> page <span class="keyword">no</span> <span class="number">3</span> n bits <span class="number">72</span> <span class="keyword">index</span> <span class="keyword">PRIMARY</span> <span class="keyword">of</span> <span class="keyword">table</span> `db`.`<span class="keyword">table</span>` trx id <span class="number">12121212</span> lock_mode X rec but <span class="keyword">not</span> gap</span><br><span class="line">锁是加在索引上的(从 <span class="keyword">index</span> <span class="keyword">primary</span> <span class="keyword">of</span> <span class="keyword">table</span> `db`.`<span class="keyword">table</span>` ) 可以看出</span><br><span class="line">记录锁有两种类型: </span><br><span class="line"><span class="number">1.</span> lock_mode X locks rec but <span class="keyword">not</span> gap</span><br><span class="line"><span class="number">2.</span> lock_mode S locks rect bot <span class="keyword">not</span> gap</span><br></pre></td></tr></table></figure>

<p><em>Gap Locks</em></p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">在db层看到的是:</span><br><span class="line"><span class="type">Record</span> Locks space id <span class="number">281</span> pages <span class="keyword">no</span> <span class="number">5</span> n bits <span class="number">72</span> <span class="keyword">index</span> idx_c <span class="keyword">of</span> <span class="keyword">table</span> `lc_3`.`a` trx id <span class="number">133588125</span> lock_mode X locks gap <span class="keyword">before</span> rec</span><br><span class="line">gap锁是用来防止<span class="keyword">insert</span>的</span><br><span class="line">锁的不是记录、而是记录之间的间隙、eg. (<span class="number">10</span>,<span class="number">20</span>)</span><br></pre></td></tr></table></figure>

<p><em>Insert intention Locks</em></p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">在db层看到的是:</span><br><span class="line"><span class="type">Record</span> Locks space id <span class="number">279</span> page <span class="keyword">no</span> <span class="number">3</span> n bits <span class="number">72</span> <span class="keyword">index</span> <span class="keyword">primary</span> <span class="keyword">of</span> <span class="keyword">table</span> `lc_3`.`t1` trx id <span class="number">133587907</span> lock_mode X <span class="keyword">insert</span> intention waiting</span><br></pre></td></tr></table></figure>

<p><em>next-Key locks</em></p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">在db看到的是:</span><br><span class="line"><span class="type">Record</span> Locks space id <span class="number">281</span> page <span class="keyword">no</span> <span class="number">5</span> n bits <span class="keyword">index</span> idx_c <span class="keyword">of</span> <span class="keyword">table</span> `lc_3`.`t1` trx id <span class="number">133587907</span> lock_mode X</span><br><span class="line">Next-Key Locks = Gap Locks + <span class="type">Record</span> Locks会同时锁住记录和间隙</span><br></pre></td></tr></table></figure>

<p><em>Anto-inc Locks</em></p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">在db层看到的结果是:</span><br><span class="line">Table Lock table xx trx id <span class="number">7498948</span> lock mode auto-inc waiting </span><br><span class="line">属于表级别的锁 http:<span class="regexp">//</span>keithlan.github.io<span class="regexp">/2017/</span><span class="number">03</span><span class="regexp">/03/</span>auto_increment_lock/</span><br></pre></td></tr></table></figure>

<p><em>显式锁 vs 隐式锁</em></p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">显式锁(explicit lock)</span><br><span class="line">显式加的锁, 在 show engine innoDB <span class="keyword">status</span> 中能够看到、会在内存中产生对象、占用内存</span><br><span class="line">eg. <span class="keyword">select</span> ... for update, <span class="keyword">select</span> ... lock <span class="keyword">in</span> share mode ....</span><br><span class="line"></span><br><span class="line">隐式锁(<span class="keyword">implicit</span> lock)</span><br><span class="line">是在索引中对记录逻辑的加锁、但实际上不产生锁对象、不占用内存空间</span><br><span class="line">eg. insert into xx values(xx)</span><br><span class="line">      update xx set t=t+<span class="number">1</span> <span class="keyword">where</span> id=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">implicit</span> lock -&gt; explicit lock</span><br><span class="line">eg. 只有当<span class="keyword">implicit</span> lock 产生冲突的时候、会自动转换成 explicit lock、降低锁开销</span><br><span class="line">eg. A会话插入记录<span class="number">10</span>、本身会加上 <span class="keyword">implicit</span> lock、但是如果B 会话更新<span class="number">10</span>这条记录、就会转换为 explicit lock</span><br></pre></td></tr></table></figure>

<p><em>metadata lock</em></p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">是<span class="keyword">server</span>层实现的锁、与引擎无关</span><br><span class="line">执行<span class="keyword">select</span>时、若有ddl语句、会被阻塞、因为 <span class="keyword">select</span> 会加上 metadata <span class="keyword">lock</span>、防止元数据在访问过程中被修改</span><br></pre></td></tr></table></figure>

<p><em>锁迁移</em></p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">锁迁移、又叫锁继承</span><br><span class="line"><span class="selector-tag">A</span>锁住的记录是一条已经被标记为删除的记录、但是还没有被puge、然后这条被标记为删除的记录、被purge掉了、上边的锁就会给了下边一条记录、称为锁迁移</span><br></pre></td></tr></table></figure>

<p><em>锁升级</em></p>
<figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">一条全表更新的语句、<span class="built_in">db</span>可能会对所有记录加锁、可能造成锁的开销很大、升级为页锁、或者表锁(mysql无锁升级)</span><br></pre></td></tr></table></figure>

<p><em>锁分裂</em></p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">1.</span> innodb 实现的加锁、其实是在页上边做的、没办法直接对记录加锁</span><br><span class="line"><span class="bullet">2.</span> 一个页被读取到内存、会产生锁对象、锁对象里会有位图信息记录哪些heap no被锁住、heapno 表示的就是堆的序列号、可以认为就是定位到某一条记录</span><br><span class="line"><span class="bullet">3.</span> insert的时候、可能会产生页分裂</span><br><span class="line"><span class="bullet">4.</span> 若页分裂、原来对页上边的加锁位图信息也就变了、为了保持这种变化和锁信息、锁对象也会分裂、继续维护分裂后页的锁信息</span><br></pre></td></tr></table></figure>

<p><em>锁合并</em></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">参考锁分裂</span><br></pre></td></tr></table></figure>

<p><em>latch vs lock</em></p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">latch:</span> mutex、rw-<span class="keyword">lock</span>、临界资源用完就释放、不支持死锁检测、应用程序维护 非<span class="built_in">db</span>锁</span><br><span class="line"><span class="symbol">lock:</span> 事务结束后释放、支持死锁检测、<span class="built_in">db</span>锁</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/6/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><span class="page-number current">7</span><a class="page-number" href="/page/8/">8</a><span class="space">&hellip;</span><a class="page-number" href="/page/17/">17</a><a class="extend next" rel="next" href="/page/8/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">niuniu</p>
  <div class="site-description" itemprop="description">多数是学习笔记、偶尔发发感慨、给生活添加些许乐趣</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">162</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
        <span class="site-state-item-count">16</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">16</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">niuniu</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
