<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.2">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="多数是学习笔记、偶尔发发感慨、给生活添加些许乐趣">
<meta property="og:type" content="website">
<meta property="og:title" content="牛牛的小窝">
<meta property="og:url" content="http://yoursite.com/page/13/index.html">
<meta property="og:site_name" content="牛牛的小窝">
<meta property="og:description" content="多数是学习笔记、偶尔发发感慨、给生活添加些许乐趣">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="niuniu">
<meta property="article:tag" content="Java, Mysql, Linux">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/page/13/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>牛牛的小窝</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">牛牛的小窝</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">不奢望岁月静好 只希望点滴积累</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/03/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95_%E9%93%BE%E8%A1%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="niuniu">
      <meta itemprop="description" content="多数是学习笔记、偶尔发发感慨、给生活添加些许乐趣">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="牛牛的小窝">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95_%E9%93%BE%E8%A1%A8/" class="post-title-link" itemprop="url">链表</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-03-20 00:00:00" itemprop="dateCreated datePublished" datetime="2020-03-20T00:00:00+08:00">2020-03-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-05-07 11:31:06" itemprop="dateModified" datetime="2022-05-07T11:31:06+08:00">2022-05-07</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">数据结构和算法</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h5 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h5><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">链表: 用指针将一组零散的内存块串联在一起、其中: 把内存块称为链表的节点</span></span><br><span class="line">为了将节点串联起来、每个链表的节点除了存储数据、还需要记录链上的下一个节点的地址(后继指针)</span><br><span class="line"></span><br><span class="line"><span class="section">分为:单链表、双链表和循环链表</span></span><br><span class="line"></span><br><span class="line"><span class="section">其中: 第一个节点称为头节点(用来记录链表的基地址)、最后一个节点称为尾节点、</span></span><br><span class="line"></span><br><span class="line">单链表的尾节点指向一个空地址NULL、</span><br><span class="line"><span class="section">循环链表: 一种特殊的单链表、与单链表的区别是: 尾节点指向链表的头节点</span></span><br><span class="line"><span class="section">双向链表: 每个节点有一个后继指针next和一个前驱指针prev</span></span><br><span class="line"></span><br><span class="line">存储相同的数据、双向链表要占据两个额外的空间来存储prev和next指针、需要更多的空间、但也带来了双向链表操作的灵活性</span><br><span class="line"></span><br><span class="line"><span class="section">一个重要思想:</span></span><br><span class="line"><span class="section">空间换时间: 在内存充足的时候、若追求代码的执行速度、可以利用空间换时间、选择空间复杂度高、但时间复杂度相对较低的算法</span></span><br><span class="line"><span class="section">相反: 若内存较少、eg. 代码跑在单片机或者手机上、就需要考虑时间换空间的思路</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="链表vs数组"><a href="#链表vs数组" class="headerlink" title="链表vs数组"></a>链表vs数组</h5><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">1.</span> 链表可有效使用内存、插入和删除效率较高</span><br><span class="line"><span class="bullet">2.</span> 数组随机访问效率更高、插入删除效率较低</span><br><span class="line"><span class="bullet">3.</span> 数组的连续存储性、可借助CPU的缓存机制、预读数组中数据、访问效率更高</span><br><span class="line">   链表存储非连续、对CPU缓存支持不够友好</span><br><span class="line"><span class="bullet">4.</span> 数组大小固定、一旦声明就要占用整块的连续空间、若声明的数组过大、系统无足够连续内存、会导致OOM、链表本身无大小限制、可天然支持动态扩容</span><br><span class="line"><span class="bullet">5.</span> 若代码对内存要求很高、则数组更合适、且: 对链表频繁的增删会导致频繁的内存申请和释放、容易造成GC</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h5 id="几个写链表代码的技巧"><a href="#几个写链表代码的技巧" class="headerlink" title="几个写链表代码的技巧"></a>几个写链表代码的技巧</h5><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">一、理解指针或者引用的含义</span><br><span class="line">   将某个变量赋值给指针、实际上就是将这个变量的地址赋值给指针、即: 指针中存储了这个变量的内存地址、指向了这个变量、通过指针就能找到这个变量</span><br><span class="line"></span><br><span class="line">二、警惕指针丢失和内存泄漏</span><br><span class="line">   插入节点时需要注意操作顺序、删除节点时也要手动释放内存</span><br><span class="line"></span><br><span class="line">三、利用哨兵简化实现难度</span><br><span class="line">   针对链表的增删操作、需要对头节点和尾节点进行特殊处理</span><br><span class="line"></span><br><span class="line">四、留意边界条件</span><br><span class="line"><span class="bullet">   1.</span> 空链表能否正常工作 ？</span><br><span class="line"><span class="bullet">   2.</span> 只有一个节点的链表能否正常工作 ？</span><br><span class="line"><span class="bullet">   3.</span> 只有两个节点能否正常工作 ？</span><br><span class="line"><span class="bullet">   4.</span> 处理头尾节点时能否正常工作 ？</span><br><span class="line"></span><br><span class="line">五、举例画图、辅助思考</span><br><span class="line"></span><br><span class="line">六、多写多练</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/03/20/%E6%B5%8F%E8%A7%88%E5%99%A8_http%E8%AF%B7%E6%B1%82%E8%A7%A3%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="niuniu">
      <meta itemprop="description" content="多数是学习笔记、偶尔发发感慨、给生活添加些许乐趣">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="牛牛的小窝">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/20/%E6%B5%8F%E8%A7%88%E5%99%A8_http%E8%AF%B7%E6%B1%82%E8%A7%A3%E6%9E%90/" class="post-title-link" itemprop="url">http请求解析</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-03-20 00:00:00" itemprop="dateCreated datePublished" datetime="2020-03-20T00:00:00+08:00">2020-03-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-05-07 11:31:06" itemprop="dateModified" datetime="2022-05-07T11:31:06+08:00">2022-05-07</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%B5%8F%E8%A7%88%E5%99%A8/" itemprop="url" rel="index"><span itemprop="name">浏览器</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="如何把数据包送达目的主机"><a href="#如何把数据包送达目的主机" class="headerlink" title="如何把数据包送达目的主机"></a>如何把数据包送达目的主机</h4><blockquote>
<p>主机A -&gt; 网络层(添加IP头信息) -&gt; 底层 -&gt; 物理网络 -&gt; 主机B -&gt; 解析IP头信息 -&gt; 将数据部分交给应用</p>
</blockquote>
<h4 id="如何把数据包送达应用程序"><a href="#如何把数据包送达应用程序" class="headerlink" title="如何把数据包送达应用程序"></a>如何把数据包送达应用程序</h4><blockquote>
<p>UDP协议: User Datagram Protocol<br>网络层和上层之间添加一层(传输层)、封装UDP头信息</p>
</blockquote>
<p>UDP并不提供重传机制、只是丢弃当前数据包、且发送之后不知道是不是数据能到达目的地</p>
<h4 id="TCP将数据完整送达应用程序"><a href="#TCP将数据完整送达应用程序" class="headerlink" title="TCP将数据完整送达应用程序"></a>TCP将数据完整送达应用程序</h4><blockquote>
<p>对于数据包丢失的情况、TCP提供重传机制<br>引入数据包排序机制、保证将乱序的数据包组合成一个完整的文件</p>
</blockquote>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">浏览器使用HTTP协议作为应用层协议、用来封装请求的文本信息</span><br><span class="line">使用TCP/<span class="built_in">IP</span>作为传输层协议 将它发在网络上</span><br><span class="line">即: HTTP请求的内容是通过TCP的传输数据阶段来实现的</span><br></pre></td></tr></table></figure>



<h4 id="HTTP请求流程"><a href="#HTTP请求流程" class="headerlink" title="HTTP请求流程"></a>HTTP请求流程</h4><ul>
<li>构建请求</li>
</ul>
<blockquote>
<p>GET &#x2F;index.html HTTP1.1</p>
</blockquote>
<ul>
<li>查找缓存</li>
</ul>
<blockquote>
<p>浏览器在网络请求之后会保存资源副本在本地</p>
<ol>
<li>缓解服务端压力、提升性能</li>
<li>对于网站来说、可以实现快速下载</li>
<li>若本地无资源副本、就会进入网络请求</li>
</ol>
</blockquote>
<ul>
<li>准备IP地址和端口</li>
</ul>
<blockquote>
<p>思考：</p>
<ol>
<li>http请求的第一步是什么呢 ？- 构建请求信息</li>
<li>建立连接的信息都包含什么? - ip和端口号</li>
<li>如果只有url可以拿到建立连接的信息么 ？- 通过DNS解析、http协议默认80端口</li>
</ol>
</blockquote>
<ul>
<li>等待TCP队列</li>
</ul>
<blockquote>
<p>准备好IP和端口、是不是就可以建立TCP连接？</p>
<p>不一定, Chrome 同一个域名最多建立6个TCP连接、若同时有10个请求、会有4个请求进入排队队列等待、直到进行中的请求完成</p>
</blockquote>
<ul>
<li>建立TCP连接</li>
</ul>
<blockquote>
<p>在http开始工作之前、需要先建立TCP连接</p>
</blockquote>
<ul>
<li>发送HTTP请求</li>
</ul>
<blockquote>
<ol>
<li>请求行(请求方法、路由、http版本)</li>
<li>请求头(cookie等信息)</li>
<li>请求体(请求参数等)</li>
</ol>
</blockquote>
<h4 id="服务端处理http请求流程"><a href="#服务端处理http请求流程" class="headerlink" title="服务端处理http请求流程"></a>服务端处理http请求流程</h4><ul>
<li>返回请求</li>
<li>断开连接(正常情况下、一单server返回响应数据、就会关闭TCP连接、若头信息加入 Connection:Keep-Alive则保持TCP连接不断开)</li>
<li>重定向</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/03/20/%E6%B5%8F%E8%A7%88%E5%99%A8_url%E8%A7%A3%E6%9E%90%E6%B5%81%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="niuniu">
      <meta itemprop="description" content="多数是学习笔记、偶尔发发感慨、给生活添加些许乐趣">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="牛牛的小窝">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/20/%E6%B5%8F%E8%A7%88%E5%99%A8_url%E8%A7%A3%E6%9E%90%E6%B5%81%E7%A8%8B/" class="post-title-link" itemprop="url">url解析流程</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-03-20 00:00:00" itemprop="dateCreated datePublished" datetime="2020-03-20T00:00:00+08:00">2020-03-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-05-07 11:31:06" itemprop="dateModified" datetime="2022-05-07T11:31:06+08:00">2022-05-07</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%B5%8F%E8%A7%88%E5%99%A8/" itemprop="url" rel="index"><span itemprop="name">浏览器</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <ul>
<li><p>浏览器进程主要负责用户交互、子进程管理和文件存储等功能</p>
</li>
<li><p>网络进程是面向渲染进程和浏览器进程等提供网络下载功能</p>
</li>
<li><p>渲染进程主要职责是把从网络下载的HTML、JS、CSS图片等资源解析为可显示赫尔交互的页面</p>
</li>
</ul>
<h4 id="请求解析流程"><a href="#请求解析流程" class="headerlink" title="请求解析流程"></a>请求解析流程</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">大致可以描述为：</span><br><span class="line"><span class="bullet">1.</span> 首先从浏览器进程输入请求URL</span><br><span class="line"><span class="bullet">2.</span> 网络进程发起URL请求</span><br><span class="line"><span class="bullet">3.</span> 服务器响应URL请求之后、浏览器进程开始准备渲染进程</span><br><span class="line"><span class="bullet">4.</span> 渲染进程准备好之后、向渲染进程提交网络进程响应的数据、称为提交文档阶段</span><br><span class="line"><span class="bullet">5.</span> 渲染进程接收完整文档信息之后、开始解析加载页面及子资源、完成页面渲染</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 用户输入</span><br><span class="line">   用户在地址栏输入查询关键字时、地址栏会判断输入的是关键字还是请求的<span class="built_in">URL</span></span><br><span class="line">   若是搜索内容、地址栏会使用浏览器默认的搜索引擎、合成包含搜索关键字的<span class="built_in">URL</span></span><br><span class="line">   若输入内容符合<span class="built_in">URL</span>规则、则解析为<span class="built_in">URL</span>、浏览器加载一个地址之后、导航栏图表就进入了加载状态、页面没变、需要等待提交文档阶段、页面内容才会替换</span><br><span class="line"><span class="number">2.</span> <span class="built_in">URL</span>请求过程</span><br><span class="line">   浏览器进程通过进程间通信IPC把url请求发送到网络进程、网络进程接收到<span class="built_in">URL</span>请求后才发起请求</span><br><span class="line">   </span><br><span class="line">   <span class="number">1</span>) 网络进程先查找本地缓存是否缓存了改资源、若有直接返回</span><br><span class="line">   <span class="number">2</span>) 没有、进入网络请求流程(DNS解析-&gt;ip、若<span class="keyword">https</span>协议先建立TLS连接)</span><br><span class="line">   <span class="number">3</span>) 利用IP地址和服务器建立TCP连接、建立连接后浏览器会构造请求信息(请求行/头)把相关cookie加入请求头、发送请求信息</span><br><span class="line">   <span class="number">4</span>) 服务器收到请求后、生产响应数据(响应行/头/体)、发给网络进程、网络进程接收到响应行和响应头之后解析响应头</span><br><span class="line">      <span class="keyword">a</span>. 重定向 - 响应码 <span class="number">301</span>|<span class="number">302</span> 从响应头提取Location、然后发起新的请求、从新开始</span><br><span class="line">      b. 响应数据类型处理</span><br><span class="line">         Content-Type标记浏览器响应类型 <span class="keyword">text</span>/html 代表返回数据是HTML格式、继续后续流程</span><br><span class="line">         application/octet-stream 返回数据是字节流类型、按照下载类型来处理、请求提交给浏览器的下载管理器</span><br><span class="line"><span class="number">3.</span> 准备渲染进程</span><br><span class="line">   默认情况下、Chrome会为每个页面分配一个渲染进程、但某些情况下会多个页面运行在同一渲染进程中</span><br><span class="line">   通常: </span><br><span class="line">   打开新的页面会使用单独的渲染进程、</span><br><span class="line">   若从A页面打开B页面、且AB属于同一站点、则B复用A页面的渲染进程、若是其它情况、会单独创建进程</span><br><span class="line">   </span><br><span class="line">   渲染进程准备好之后、不能立即进入文档解析阶段、因为此时文档还在网络进程中、并未提交给渲染进程、所以下一步是进入提交文档阶段</span><br><span class="line">   </span><br><span class="line"><span class="number">4.</span> 提交文档</span><br><span class="line">   提交文档(响应数据)的请求是浏览器进程发出的、渲染进程接收到消息后、会和网络进程建立传输数据的通道</span><br><span class="line">   文档数据传输完成后、渲染进程返回 确认提交 的消息给浏览器进程</span><br><span class="line">   浏览器进程在收到确认提交的消息后、更新浏览器界面状态、包含了安全状态、地址栏的url、前进后退的历史状态、并更新web界面</span><br><span class="line">   </span><br><span class="line">   一个完整的导航走完了、进入渲染阶段</span><br><span class="line">   </span><br><span class="line"><span class="number">5.</span> 渲染阶段</span><br><span class="line">   文档一旦被提交、渲染进程就开始页面解析和子资源加载了、一旦页面生成、渲染进程会给浏览器进程发送消息、浏览器进程收到消息停止标签页上的加载动画</span><br><span class="line">   </span><br></pre></td></tr></table></figure>


<p><img src="https://upload-images.jianshu.io/upload_images/14027542-26a86c6a9a0ae591.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="浏览器加载页面.png"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/03/20/%E6%B5%8F%E8%A7%88%E5%99%A8_%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E6%B5%81%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="niuniu">
      <meta itemprop="description" content="多数是学习笔记、偶尔发发感慨、给生活添加些许乐趣">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="牛牛的小窝">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/20/%E6%B5%8F%E8%A7%88%E5%99%A8_%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E6%B5%81%E7%A8%8B/" class="post-title-link" itemprop="url">浏览器渲染流程</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-03-20 00:00:00" itemprop="dateCreated datePublished" datetime="2020-03-20T00:00:00+08:00">2020-03-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-05-07 11:31:06" itemprop="dateModified" datetime="2022-05-07T11:31:06+08:00">2022-05-07</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%B5%8F%E8%A7%88%E5%99%A8/" itemprop="url" rel="index"><span itemprop="name">浏览器</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>HTML的内容由标记和文本组成、也称标签</p>
<p>CSS又称 层叠样式表、由选择器和属性组成</p>
<p>JS 使页面内容动起来</p>
<p>渲染模块在执行过程中分为很多子阶段、输入的HTML经过这些子阶段、输出像素、这个处理过程称为 渲染流水线</p>
<ol>
<li><p>构建DOM树</p>
<blockquote>
<p>浏览器无法直接理解和使用html、需要先转化为其能理解的结构 - DOM树</p>
<p>构建dom树的输入是简单的html文件、经过html解析器解析、输出 树状结构的DOM</p>
<p>DOM和html的内容基本一致、但dom是保存在内存中的树状就结构、可以通过JS直接修改</p>
</blockquote>
</li>
<li><p>样式计算</p>
<blockquote>
<p>是为了计算出DOM节点中每个元素的具体样式</p>
<ol>
<li><p>将CSS转化为浏览器可理解的结构 stylesheets</p>
</li>
<li><p>转换样式表中的属性值、使其标准化 eg. 2em -&gt; 32px  blue -&gt; rgb(0,0,255)</p>
</li>
<li><p>计算出dom树中每个节点的具体样式</p>
</li>
</ol>
</blockquote>
</li>
<li><p>布局计算</p>
<blockquote>
<p>计算dom树中可见元素的几何位置</p>
<ol>
<li><p>创建布局树 遍历dom节点、将这些节点加载到布局中</p>
</li>
<li><p>布局计算 将布局运算的结果写回布局树</p>
</li>
</ol>
</blockquote>
</li>
<li><p>分层</p>
<blockquote>
<p>为了更方便的实现3D变换、页面滚动或者使用z-indexing做z轴排序等</p>
<p>渲染引擎还需要为特定的节点生成专用图层、并生成一棵对应的图层树LayerTree</p>
<p>浏览器的页面其实是很多图层、这些图层叠加后合成了最终的页面</p>
<p>并不是所有的布局树的每个节点都包含一个图层、若节点无对应图层、则从属于父节点的图层</p>
<ol>
<li><p>拥有层叠上下文属性的元素会被提升为单独的一层</p>
</li>
<li><p>需要裁剪的地方也会被创建为图层</p>
</li>
</ol>
</blockquote>
</li>
<li><p>绘制</p>
<blockquote>
<p>图层的绘制与画画的流程基本一致、会把一个图层的绘制拆分成很多小的绘制指令、然后将指令按照顺序组成一个待绘制列表</p>
</blockquote>
</li>
<li><p>栅格化</p>
<blockquote>
<p>绘制列表只是用来记录绘制顺序和绘制指令的列表、而实际上绘制操作是由渲染引擎中的合成线程来完成(图层绘制列表准备完成后、主线程会把绘制列表提交给合成线程)</p>
<p>通常、栅格化过程会使用GPU来加速生成、使用GPU生成位图的过程叫 快速栅格化、生成的位图保存在GPU内存中</p>
</blockquote>
</li>
<li><p>合成</p>
<blockquote>
<p>所有图块被光栅化之后、合成进程会生成一个绘制图块的命令、提交给浏览器进程</p>
<p>浏览器进程的viz组件、接收绘制命令绘制内容显示到浏览器</p>
</blockquote>
</li>
</ol>
<h4 id="几个概念"><a href="#几个概念" class="headerlink" title="几个概念"></a>几个概念</h4><p><code>重排</code>: 通过JS或者CS修改元素几何位置、eg. 改变元素的宽、高、等会触发重新布局、解析之后的一系列子阶段、这个过程就叫重排、需要更新完整的渲染流水线、开销很大</p>
<p><code>重绘</code>: eg. JS更改某些元素的背景色、布局阶段不会重新执行、直接进入绘制阶段、然后执行之后的子阶段、相对<code>重排</code> 少了<code>布局</code>和<code>分层</code>阶段、执行效率会高一些</p>
<p><code>直接合成阶段</code>: eg. 使用CSS的transform来实现动画、可以避开<code>重排</code>和<code>重绘</code>阶段、直接在非主线程上执行合成动画操作、大大提升绘制效率</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/03/20/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE_DHCP%E4%B8%8EPXE--ip%E6%98%AF%E6%80%8E%E4%B9%88%E6%9D%A5%E7%9A%84%E3%80%81%E5%8F%88%E6%98%AF%E6%80%8E%E4%B9%88%E6%B2%A1%E7%9A%84--/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="niuniu">
      <meta itemprop="description" content="多数是学习笔记、偶尔发发感慨、给生活添加些许乐趣">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="牛牛的小窝">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/20/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE_DHCP%E4%B8%8EPXE--ip%E6%98%AF%E6%80%8E%E4%B9%88%E6%9D%A5%E7%9A%84%E3%80%81%E5%8F%88%E6%98%AF%E6%80%8E%E4%B9%88%E6%B2%A1%E7%9A%84--/" class="post-title-link" itemprop="url">DHCP与PXE--ip是怎么来的、又是怎么没的--</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-03-20 00:00:00" itemprop="dateCreated datePublished" datetime="2020-03-20T00:00:00+08:00">2020-03-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-05-07 11:31:06" itemprop="dateModified" datetime="2022-05-07T11:31:06+08:00">2022-05-07</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/" itemprop="url" rel="index"><span itemprop="name">网络协议</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="如何配置ip地址"><a href="#如何配置ip地址" class="headerlink" title="如何配置ip地址"></a>如何配置ip地址</h4><ol>
<li>使用net-tools<figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>sudo ifconfig eth1 <span class="number">10.0</span>.<span class="number">0.1</span>/<span class="number">24</span></span><br><span class="line"><span class="variable">$ </span>sudo ifconfig eth1 up</span><br></pre></td></tr></table></figure></li>
<li>使用iprote2<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo<span class="built_in"> ip </span>addr <span class="built_in">add</span> 10.0.0.1/24 dev eth1</span><br><span class="line">$ sudo<span class="built_in"> ip </span>link <span class="built_in">set</span> up eth1</span><br></pre></td></tr></table></figure>
但: 是可以随意配置的吗 ?<blockquote>
<p>显然不是. 只要在网络上的包、都是完整的、可以有下层无上层、不能反之.<br>若配置为不同网段, 发送请求包时、linux的默认逻辑是: 跨网段调用、不会直接将包发送到网络上、而是企图发送到网关.<br>若配置同网段呢? – 会配置失败</p>
</blockquote>
</li>
</ol>
<h4 id="动态主机配置协议-DHCP"><a href="#动态主机配置协议-DHCP" class="headerlink" title="动态主机配置协议(DHCP)"></a>动态主机配置协议(DHCP)</h4><p><code>DHCP</code>: 动态主机配置协议(Dynamic Host Configuration Protocol)<br>有了DHCP、网络管理员只需要配置一段共享的ip地址. 每一台新接入的机器会通过DHCP协议去共享的ip地址里申请、然后自动配置 </p>
<blockquote>
<p>若数据中心里的服务器、ip一旦配置好、基本不会改变、相当于自己买房、自己装修. DHCP的方式类似于租房、临时借用、用完归还即可.</p>
</blockquote>
<h4 id="解析DHCP的工作方式"><a href="#解析DHCP的工作方式" class="headerlink" title="解析DHCP的工作方式"></a>解析DHCP的工作方式</h4><p>刚加入网络的机器、暂无ip地址、处于<code>DHCP Discover</code>的状态.</p>
<p>它会使用ip地址 0.0.0.0 发送广播包、目的地址为: 255.255.255.255. 广播包封装了UDP、UDP封装了BOOTP. 若网络里配置了DHCP Server, Server会分配ip地址给该MAC地址、同时记录(不会分配给其它机器). 这个过程称为 <code>DHCP Offer</code>.</p>
<p>若收到多个DHCP Server回复、一般会选择接受第一个到达的、且向网络发送一个DHCP Request广播数据包, 包含Clineet的MAC地址、接受的ip地址、提供该ip的HDCP Server地址等, 告诉其它server它接受了哪一台server提供的ip、请求他们撤销提供的ip、以提供给下一个ip租用者.</p>
<p>DHCP Server 接收到Client的request后、会广播返回一个ACK消息.</p>
<p>client会在租期过去50%时、向为其提供ip地址的server发送request消息包, client 再根据接收到server回应的ack消息包中提供的新的租期及其他已更新的tcp&#x2F;ip参数更新自己的配置.</p>
<h4 id="预启动执行环境-PXE"><a href="#预启动执行环境-PXE" class="headerlink" title="预启动执行环境(PXE)"></a>预启动执行环境(PXE)</h4><p>预启动执行环境: </p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/03/20/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE_ifconfig/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="niuniu">
      <meta itemprop="description" content="多数是学习笔记、偶尔发发感慨、给生活添加些许乐趣">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="牛牛的小窝">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/20/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE_ifconfig/" class="post-title-link" itemprop="url">ifconfig</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-03-20 00:00:00" itemprop="dateCreated datePublished" datetime="2020-03-20T00:00:00+08:00">2020-03-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-05-07 11:31:06" itemprop="dateModified" datetime="2022-05-07T11:31:06+08:00">2022-05-07</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/" itemprop="url" rel="index"><span itemprop="name">网络协议</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p><code>ip地址</code>是一个网卡在网络世界的通信地址、类似<code>门牌号</code></p>
</blockquote>
<p><img src="https://upload-images.jianshu.io/upload_images/14027542-73bac7cc574fb7e9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="32位ip地址分类.png"></p>
<h4 id="无类型域间选路-CIDR"><a href="#无类型域间选路-CIDR" class="headerlink" title="无类型域间选路(CIDR)"></a>无类型域间选路(CIDR)</h4><p>从上图可以看到、C类地址能包含的主机数只有 2<sup>8</sup> &#x3D; 254个, 数量过少; 而B类地址能包含的最大主机数量又太多了、一般企业规模达不到65534、剩余的地址就是浪费.</p>
<p>于是产生了一个折中方案: CIDR. 打破ip类别设计、将32位ip一分为二、前边是网络号、后边是主机号.<br>eg. 10.100.122.2&#x2F;24<br><code>/ </code> 表示前24位代表网络号、后8位是主机号</p>
<p>伴随CIDR存在的还有<code>广播地址</code> 和 <code>子网掩码</code>.<br>广播地址是: 10.100.122.255, 若发送这个地址、所有10.100.122 网络里的机器都可以收到<br>子网掩码: 255.255.255.0</p>
<p>将子网掩码 和 ip 进行 AND运算、可以得到网络号</p>
<h4 id="公有ip地址-和-私有ip地址"><a href="#公有ip地址-和-私有ip地址" class="headerlink" title="公有ip地址 和 私有ip地址"></a>公有ip地址 和 私有ip地址</h4><p><img src="https://upload-images.jianshu.io/upload_images/14027542-6f0cb3fd1a380ca4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="私有ip地址范围.png"></p>
<p><code>组播地址</code>: 属于某个组的机器都能收到消息.<br>eg. 邮件组</p>
<p>在ip地址的后边、有个scope, 对eth0这个网卡来讲、是global, 说明这个网卡是可以对外的、可以接收来自各个地方的包. 对于lo来讲、是host, 说明这张网卡仅可以供本机相互通信.</p>
<p>lo 全程 loopback, 又称<code>回环接口</code>, 往往被分配打平 127.0.0.1 这个地址、经过内核处理后直接返回、不会在任何网络中出现.</p>
<h4 id="MAC地址"><a href="#MAC地址" class="headerlink" title="MAC地址"></a>MAC地址</h4><p><code>MAC地址</code>是一个网卡的物理地址、十六进制表示、6个byte、全局唯一. 但不可替代ip地址.<br>类似: 身份证号全网唯一、但若在问路时、被人知道的概率确很小、ip具有定位功能、类似省市区街道小区的概念、</p>
<p>MAC地址本身更像是身份证、是唯一标识. 设计唯一性是为了不同网卡放在同一网络时、可以不用担心冲突. 从硬件角度、确保不同网卡有不同标识.</p>
<p>MAC具有一定定位功能、但范围有限. 局限在同一子网. 跨子网的情况、就需要ip地址来查找了.</p>
<h4 id="网络设备的状态标识"><a href="#网络设备的状态标识" class="headerlink" title="网络设备的状态标识"></a>网络设备的状态标识</h4><p>&lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; 是干什么的？这个叫作 net_device flags，网络设备的状态标识</p>
<p>UP 代表网卡处于启动的状态<br>BROADCAST 表示网卡有广播地址、可以发送广播<br>MULTICAST 表示网卡可以发送多播包<br>LOWER_UP 表示L1是启动的, 即: 网线插着呢</p>
<p>mtu 1500 呢 ? 代表最大传输MTU为1500, 这个是以太网的默认值<br>网络是层层封装的, MTU是二层MAC概念. MAC层有MAC层的头、以太网规定连MAC头带正文合起来不能超过1500个字节、正文里有ip、tcp、http的头,<br>若放不下、就需要分片来传输.</p>
<p><code>qdisc pfifo_fast</code> 全称<code>queueing discipline</code>, 即<code>排队规则</code>. 内核若需要通过某个网络接口发送数据包、就需要按照为这个接口配置的qdisc将数据包加入队列.<br>最简单的qdisc是 pfifo, 它不对进入的数据包做任何处理、数据包采用先入先出的方式通过队列. pfifo_fast 稍微复杂些、它的队列包括3个波段(band)、在每个波段里使用先进先出的规则. band 0的优先级最高, band 2的最低, 若band 0里有数据包、系统就不会处理band 1里的数据包.</p>
<p>数据包是按照服务类型(<code>Type of Service, TOS</code>)被分配到三个波段的、TOS是 IP 头里边的一个字段、代表了当前包的优先级.</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/03/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86_CPU%E5%8F%91%E5%B1%95%E5%9B%9E%E9%A1%BE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="niuniu">
      <meta itemprop="description" content="多数是学习笔记、偶尔发发感慨、给生活添加些许乐趣">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="牛牛的小窝">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86_CPU%E5%8F%91%E5%B1%95%E5%9B%9E%E9%A1%BE/" class="post-title-link" itemprop="url">CPU发回顾</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-03-20 00:00:00" itemprop="dateCreated datePublished" datetime="2020-03-20T00:00:00+08:00">2020-03-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-05-07 11:31:06" itemprop="dateModified" datetime="2022-05-07T11:31:06+08:00">2022-05-07</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86/" itemprop="url" rel="index"><span itemprop="name">计算机原理</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">指令周期: Fetch -&gt; Decode -&gt; Execute</span><br><span class="line"></span><br><span class="line">CPU周期: 从内存取出一条指令的最短时间(一个指令周期至少需要<span class="number">2</span>个CPU周期)</span><br><span class="line"></span><br><span class="line">通过D触发器实现存储功能</span><br><span class="line">通过时钟信号实现计数器</span><br><span class="line"></span><br><span class="line">一个时钟周期内确保完成一条最复杂的CPU指令 -&gt; 单指令周期处理器</span><br><span class="line">译码器 -&gt; 从输入的多个位的信号中、根据一定的开关和电路组合、选择出自己想要的信号</span><br><span class="line">优化<span class="number">1</span>: CPU流水线设计(保障一个最复杂的流水线级在一个时钟周期内完成即可)</span><br><span class="line">       不能优化单条指令执行延时、可以提高CPU的吞吐率(可同时并行多条指令)</span><br><span class="line">       </span><br><span class="line">       缺点: 流水线深度增加带来性能成本、每级流水线的输出需放到流水线寄存器、然后在下一个时钟周期、交给下一个流水线级处理、每增加一级就要多一次写入流水线寄存器的操作(<span class="number">20ps</span>)</span><br><span class="line">       为了保证指令的响应时间这个指标、只有提升时钟周期、电路数量和晶体管数量都会增加、功耗变大</span><br><span class="line">       </span><br><span class="line">       挑战: 冒险和分支预测</span><br><span class="line"> </span><br><span class="line">优化<span class="number">2</span>: 结构冒险 -&gt; 增加资源(eg. 数据内存和指令内存分开, 现代CPU只将CPU内部的缟素缓存分成指令缓存和数据缓存)</span><br><span class="line"></span><br><span class="line">优化<span class="number">3</span>: 数据冒险 -&gt; 流水线停顿(插入NOP操作), 最差会退化成单指令周期CPU</span><br><span class="line">优化<span class="number">4</span>: 数据冒险 -&gt; 操作数前推(操作数转发、节省了写入写入寄存器、从寄存器读出的时间)</span><br><span class="line">优化<span class="number">5</span>: 乱序执行 -&gt; 将指令发送到保留站 -&gt; 提交到不同的FU -&gt; 重排缓存区重排<span class="function"><span class="params">(cpu按照取指顺序、对指令结果重排, 只有排在前边的都完成、才提交指令、完成指令运算)</span> -&gt;</span> 指令提交</span><br><span class="line">       提高了CPU的吞吐量</span><br><span class="line">优化<span class="number">6</span>: 分支预测(缩短分支延迟、动态分支预测、静态分支预测)</span><br><span class="line">优化<span class="number">7</span>: 超标量(多发射, 让cpi&gt;<span class="number">1</span>, 并行取指、译码 -&gt; 需要增加电路元件)</span><br><span class="line">优化<span class="number">8</span>: 超线程: 在一个CPU内部、有双份PC寄存器、指令寄存器、条件码寄存器、同时维护两个并行指令的状态(指令译码器、ALU都只有单份)</span><br><span class="line">优化<span class="number">9</span>: SIMD(单指令多数据流):一次加载多个整数、然后使用多个FU并行计算(MMX)</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/03/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86_CPU%E6%80%A7%E8%83%BD%E6%9E%81%E8%87%B4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="niuniu">
      <meta itemprop="description" content="多数是学习笔记、偶尔发发感慨、给生活添加些许乐趣">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="牛牛的小窝">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86_CPU%E6%80%A7%E8%83%BD%E6%9E%81%E8%87%B4/" class="post-title-link" itemprop="url">CPU性能极致</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-03-20 00:00:00" itemprop="dateCreated datePublished" datetime="2020-03-20T00:00:00+08:00">2020-03-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-05-07 11:31:06" itemprop="dateModified" datetime="2022-05-07T11:31:06+08:00">2022-05-07</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86/" itemprop="url" rel="index"><span itemprop="name">计算机原理</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="超线程"><a href="#超线程" class="headerlink" title="超线程"></a>超线程</h4><blockquote>
<p>在一个物理CPU核心内部、有双份的PC寄存器、指令寄存器和条件码寄存器、这样这个CPU核心就可以维护两条并行的指令的状态、在外部看起来似乎有两个逻辑层面的CPU在同时运行. so 又称为同时多线程(SMT: Simulataneous Multi-Threading)、但其它功能组件依然是一份、因为超线程不是真的同时运行两个指令、而是在一个线程A的指令在流水线里停顿的时候、让空闲的CPU译码器和ALU去执行线程B的指令</p>
</blockquote>
<h4 id="SIMD-单指令多数据流"><a href="#SIMD-单指令多数据流" class="headerlink" title="SIMD 单指令多数据流"></a>SIMD 单指令多数据流</h4><blockquote>
<p>一种指令级并行的加速方案、在处理向量计算的情况下、同一个向量的不同维度直接的计算是相互独立的、而CPU里的寄存器、又可以放得下多条数据、所以可以一次性取出多条数据、交给CPU并行执行</p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/03/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86_DMA--%E4%B8%BA%E4%BB%80%E4%B9%88Kafka%E8%BF%99%E4%B9%88%E5%BF%AB-(48%E8%AE%B2)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="niuniu">
      <meta itemprop="description" content="多数是学习笔记、偶尔发发感慨、给生活添加些许乐趣">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="牛牛的小窝">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86_DMA--%E4%B8%BA%E4%BB%80%E4%B9%88Kafka%E8%BF%99%E4%B9%88%E5%BF%AB-(48%E8%AE%B2)/" class="post-title-link" itemprop="url">DMA--为什么Kafka这么快-(48讲)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-03-20 00:00:00" itemprop="dateCreated datePublished" datetime="2020-03-20T00:00:00+08:00">2020-03-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-05-07 11:31:06" itemprop="dateModified" datetime="2022-05-07T11:31:06+08:00">2022-05-07</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86/" itemprop="url" rel="index"><span itemprop="name">计算机原理</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p>SSD的IOPS可以达到2w、4w, 可CPU主频在2GHZ以上、每秒可以有2亿次操作, 若对于IO操作、都是由CPU发出对应的指令、然后等待IO设备完成操作之后返回、那CPU有大部分的时间在等待IO. 其实对于IO设备的大量操作、都只是把内存数据传输到IO设备而已、CPU是无效等待, 于是, 就有了 <code>DMA</code>(Direct Memory Access)<code>直接内存访问</code> 技术</p>
</blockquote>
<h4 id="理解DMA、一个协处理器"><a href="#理解DMA、一个协处理器" class="headerlink" title="理解DMA、一个协处理器"></a>理解DMA、一个协处理器</h4><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">本质上:</span> DMA技术就是在主板上放一块独立的芯片, 在进行内存与IO设备的数据传输时, 不在通过CPU来控制</span><br><span class="line">数据传输、而是通过`DMA控制器`(`DMAC`), 这块芯片可以认为就是一个`协处理器`</span><br><span class="line"></span><br><span class="line">DMAC最有价值的地方体现在, 当要传输的数据特别大、速度特别快, 或者传输的数据特别小、速度特别慢时.</span><br><span class="line">eg. <span class="number">1</span>. 用千兆网卡或者硬盘传输大量数据时、若都用CPU来搬运的话、肯定忙不过来、所以, 选择DMAC</span><br><span class="line">    <span class="number">2</span>. 数据传输很慢时, DMAC可以等数据到齐了、再发送信号给CPU处理、而不是让CPU在那里忙等待.</span><br><span class="line"></span><br><span class="line">DMAC在控制数据传输时、还是需要CPU的.</span><br><span class="line"></span><br><span class="line">总线上的设备包括`主设备`和`从设备`, 主动发起数据传输的、必须是主设备, eg.CPU<span class="comment">;从设备只能接收数据. </span></span><br><span class="line"><span class="title">所以:</span> 只能是 CPU从IO设备读数据、或者是CPU向IO设备写数据.</span><br><span class="line"></span><br><span class="line">IO设备不能向主设备发起请求吗？</span><br><span class="line">可以. 但发送的不是实际的数据内容, 而是控制信号. IO设备可以告诉CPU, 有数据要传输、实际数据由CPU</span><br><span class="line">拉取, 而不是IO设备主动推送给CPU.</span><br></pre></td></tr></table></figure>
<p><img src="https://upload-images.jianshu.io/upload_images/14027542-c4145e8dae426f5f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="包含DMAC的数据传输.png"></p>
<figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">DMAC</span>既是一个主设备、有是一个从设备. 对<span class="symbol">CPU</span>来说、它是从设备, 对<span class="symbol">IO</span>设备来说、它是主设备.</span><br><span class="line">使用<span class="symbol">DMAC</span>进行数据传输的过程如下:</span><br><span class="line"><span class="number">1.</span> <span class="symbol">CPU</span>作为一个主设备、向<span class="symbol">DMAC</span>设备发起请求(就是在<span class="symbol">DMAC</span>里修改配置寄存器).</span><br><span class="line"><span class="number">2.</span> <span class="symbol">CPU</span>修改<span class="symbol">DMAC</span>寄存器的时候, 会告诉<span class="symbol">DMAC</span>几个信息:</span><br><span class="line">   <span class="number">1</span>) 源地址的初始值及传输时的地址增减方式</span><br><span class="line">       源地址: 数据要从哪里传输过来. eg. 从内存写入硬盘时, 就是一个内存地址</span><br><span class="line">              从硬盘读取到内存时, 就是硬盘的<span class="symbol">IO</span>接口的地址.</span><br><span class="line">       地址的增减方式: 是说数据从大的地址向小的地址传输, 还是从晓得地址往大的地址传输.</span><br><span class="line">   <span class="number">2</span>) 目标地址初始值及传输时的地址增减方式</span><br><span class="line">   <span class="number">3</span>) 要传输的数据长度</span><br><span class="line"><span class="number">3.</span> 设置完这些信息<span class="symbol">DMAC</span>就变成一个空闲的状态idle</span><br><span class="line"><span class="number">4.</span> 若从硬盘 -&gt; 内存加载数据, 硬盘会向<span class="symbol">DMAC</span>发起一个数据传输请求,这个请求是通过额外的连线(不是总线)</span><br><span class="line"><span class="number">5.</span> <span class="symbol">DMAC</span>再通过一个额外的连线响应该请求.</span><br><span class="line"><span class="number">6.</span> 于是, <span class="symbol">DMAC</span>再向内存发起总线读的数据传输请求, 就从硬盘读到了<span class="symbol">DMAC</span>控制器里.</span><br><span class="line"><span class="number">7.</span> 然后、<span class="symbol">DMAC</span>再向我们的内存发起写的请求、把数据写入内存</span><br><span class="line"><span class="number">8.</span> <span class="symbol">DMAC</span>会反复进行<span class="number">6</span>、<span class="number">7</span> 的操作, 直到<span class="symbol">DMAC</span>的寄存器里边设置的数据长度传输完成.</span><br><span class="line"><span class="number">9.</span> 数据传输完成之后、<span class="symbol">DMAC</span>重新回到第三步的空闲状态.</span><br><span class="line"></span><br><span class="line">整个数据传输的过程中，我们不是通过 <span class="symbol">CPU</span> 来搬运数据，而是由 <span class="symbol">DMAC</span> 这个芯片来搬运数据.</span><br><span class="line">但是 <span class="symbol">CPU</span> 在这个过程中也是必不可少的. 因为传输什么数据，从哪里传输到哪里，其实还是 <span class="symbol">CPU</span> 来设置的.</span><br><span class="line">这也是为什么，<span class="symbol">DMAC</span> 被叫作<span class="string">`协处理器`</span></span><br><span class="line"></span><br><span class="line">早期的计算机里没有<span class="symbol">DMAC</span>、所有数据都是<span class="symbol">CPU</span>来搬运的、然后出现了主板上独立的<span class="symbol">DMAC</span>控制器.</span><br><span class="line">现在数据传输要求越来越复杂、加上显卡、网卡、硬盘等各个设备对数据传输的需求不同、各个设备</span><br><span class="line">都有自己的<span class="symbol">DMAC</span>芯片了</span><br></pre></td></tr></table></figure>

<h4 id="Kafka为什么这么快"><a href="#Kafka为什么这么快" class="headerlink" title="Kafka为什么这么快"></a>Kafka为什么这么快</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">kafka 是一个用来处理实时数据的管道, 常用来做消息队列、或者收集和落地海量的日志. </span><br><span class="line">作为一个实时数据和日志的管道、瓶颈自然也在IO层面</span><br><span class="line"></span><br><span class="line">kafka常见的两种海量数据传输: 1.从网络接收上游数据,落地到本地磁盘 2.从本地磁盘读取、发送到网络上.</span><br><span class="line"></span><br><span class="line">先看场景2, 最直观的是用一个文件读操作, 从磁盘把数据读到内存、再通过一个socket、把数据发到网络上.</span><br><span class="line"></span><br><span class="line">File.read(fileDesc, buf, len);</span><br><span class="line">Socket.send(socket, buf, len);</span><br><span class="line"></span><br><span class="line">这样会有四次数据传输:(两次DMA、两次通过CPU控制的传输)</span><br><span class="line"><span class="bullet">1.</span> 从硬盘上、读到操作系统内核缓冲区(通过DMA搬运).</span><br><span class="line"><span class="bullet">2.</span> 将内核缓冲区的数据、复制到应用分配的内存里(通过CPU搬运)</span><br><span class="line"><span class="bullet">3.</span> 从应用的内存、写到操作系统Socket的缓冲区里(CPU搬运)</span><br><span class="line"><span class="bullet">4.</span> 从Socket的缓冲区、写到网卡的缓冲区(DMA)</span><br></pre></td></tr></table></figure>
<p><img src="https://upload-images.jianshu.io/upload_images/14027542-1827f1506ed4ab8f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="本次磁盘到网络的数据传输过程.png"></p>
<figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">其实只需要搬运一份数据、却搬运了<span class="number">4</span>次、且: 从内核的缓冲区传输到应用的内存里、再从应用的内存里</span><br><span class="line">传输到<span class="built_in">socket</span>的缓冲区里、其实是把一份数据在内存里搬来搬去, 所以kafka就调用Java NIO库、</span><br><span class="line">FileCahnnel-&gt;transfer <span class="built_in">to</span> 方法, 将数据直接通过Channel写入到对应网络设备, 且对于<span class="built_in">socket</span>的操作、</span><br><span class="line">也不是写到<span class="built_in">socket</span>的buffer里、而是直接根据描述符写入到网卡的缓冲区, 省去了<span class="number">2</span>、<span class="number">3</span>, 只有两次数据传输.</span><br></pre></td></tr></table></figure>
<p><img src="https://upload-images.jianshu.io/upload_images/14027542-b190e4dc04bd2a64.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="kafka的数据传输模型.png"></p>
<figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">这样、同一份数据的传输次数从<span class="number">4</span>次变成了<span class="number">2</span>次、且没有通过CPU传输、都是DMA传输, 在这个方法里、</span><br><span class="line">没有在内存层面copy数据, 也称为`零拷贝`(Zero-Copy)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/03/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86_FPGA%E5%92%8CASIC(32%E8%AE%B2)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="niuniu">
      <meta itemprop="description" content="多数是学习笔记、偶尔发发感慨、给生活添加些许乐趣">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="牛牛的小窝">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86_FPGA%E5%92%8CASIC(32%E8%AE%B2)/" class="post-title-link" itemprop="url">FPGA和ASIC(32讲)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-03-20 00:00:00" itemprop="dateCreated datePublished" datetime="2020-03-20T00:00:00+08:00">2020-03-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-05-07 11:31:06" itemprop="dateModified" datetime="2022-05-07T11:31:06+08:00">2022-05-07</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86/" itemprop="url" rel="index"><span itemprop="name">计算机原理</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="FPG"><a href="#FPG" class="headerlink" title="FPG"></a>FPG</h4><blockquote>
<p>CPU其实是一些简单的门电路搭建而成、从最简单的门电路、搭建成半加器、全加器, 然后再搭建完整功能的ALU. 这些功能有完成各种实际计算功能的组合逻辑电路、也有用来控制数据访问、创建出寄存器和内存的时序逻辑电路, 一个<code>4核</code> <code>i7</code>的CPU、大约有20亿个晶体管.</p>
</blockquote>
<p>思考:</p>
<blockquote>
<p>如何保证连接20亿晶体管时不出错 ？若每验证一次bug就重新生成一块芯片、代价过高.</p>
</blockquote>
<figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">现场可编程门阵列(Filed-Programmable Gate <span class="built_in">array</span>)解决了这个问题.</span><br><span class="line">P: Programmable, 可通过编程来控制的硬件</span><br><span class="line">G: Gate, 代码芯片里的门电路, 各种编程功能的实现、依赖的就是一个个的门电路</span><br><span class="line">A: <span class="built_in">Array</span>, 阵列, 是说在一块<span class="string">`FPGA`</span>上、布满了大量的门电路</span><br><span class="line">F: 一块<span class="string">`FPGA`</span>的板子、可以多次进行编程、不像<span class="string">`PAL`</span>(Programming <span class="built_in">Array</span> Logic, 可编程阵列逻辑)这样古老的硬件设备、只能编程一次.</span><br></pre></td></tr></table></figure>

<p>思考:</p>
<blockquote>
<p>如何对硬件进行编程呢 ?</p>
</blockquote>
<figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">CPU其实是通过晶体管、来实现各种组合逻辑或者时序逻辑、如何去`编程`这些线路呢 ?</span><br><span class="line">一、用存储功能实现组合逻辑</span><br><span class="line">在实现CPU时、需要完成各种各样的电路逻辑、在FPGA里、这些基本的电路逻辑、不是采用布线连接的方式进行的、</span><br><span class="line">而是预先根据软件里设计的逻辑电路、算出对应的真值表、然后直接存到`LUT(Look-Up Table, 查找表)`的电路中</span><br><span class="line">(其实就是一块存储空间、存储了输入特定信号时、对应输出是<span class="number">0</span>还是<span class="number">1</span>)</span><br><span class="line"><span class="title">如图(Look-Up Table)示:</span></span><br><span class="line">这个查表的方法、其实就是FPGA通过LUT来实现各种组合逻辑的方法</span><br><span class="line"></span><br><span class="line">二、对于需要实现的时序逻辑电路、可以在FPGA里直接放上`D触发器`、作为`寄存器`. </span><br><span class="line">和CPU里的触发器本质相同、会把多个LUT的电路和寄存器组合在一起(称为`逻辑簇`). </span><br><span class="line">在FPGA里、组合了多个LUT和寄存器的设备叫 `CLB`(Configurable Logic Block, 可配置逻辑块)</span><br><span class="line">通过配置CLB实现的功能类似全加器、是基础电路上的组合、可提供更复杂的功能、更复杂的芯片可以从CLB组合搭建、不用从基本门电路</span><br><span class="line"></span><br><span class="line">三、FPGA是通过可编程逻辑布线来连接各个不同的CLB、最终实现我们想要的功能芯片. </span><br><span class="line">可类比为铁路网、整个铁路系统已经铺好、单设计了很多岔道、通过控制岔道来确定不同列车的线路. </span><br><span class="line">在可编程逻辑布线里、编程做的、就是拨动像岔道一样的各个电路开关、最终实现CLB之间的连接、完成我们想要的功能</span><br></pre></td></tr></table></figure>
<p><img src="https://upload-images.jianshu.io/upload_images/14027542-71a87f3241540b00.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Look-Up Table.png"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/14027542-7a1ee5e4e7844f2e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<h4 id="ASIC"><a href="#ASIC" class="headerlink" title="ASIC"></a>ASIC</h4><blockquote>
<p>虽然在手机或者录音笔上塞上一个Intel的CPU可以实现拍照、录音等功能、但, 显然比较浪费、于是: 考虑为专门用途的场景、设计单独芯片, 称为:<br><code>ASIC(Application-Specifed Integrated Circuit)</code> -&gt; 专用集成电路, 电路比较精简、制造成本也比CPU低、功耗也较小</p>
</blockquote>
<p>思考:</p>
<blockquote>
<p>可以FPGA实现ASIC的事情吗?</p>
</blockquote>
<figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">可以、而且成本和功耗上要优于做通用计算的CPU和GPU、</span><br><span class="line"></span><br><span class="line"><span class="title">那:</span> 为什么不直接使用FPGA替代ASIC呢 ?</span><br><span class="line">硬件上的浪费. 每一个门电路都是一个小小浪费、一个LUT电路设计出来、既可以实现`与`门、</span><br><span class="line">又可以实现`或`门、用到的晶体管是比单一功能要多的、单品FPGA的生成制造成本也较高</span><br><span class="line"><span class="title">FPGA的优点是:</span> 无硬件研发成本、ASIC的电路设计、需要仿真、验证、还要经过六篇、变成一个印刷的电路板、最终变成芯片、</span><br><span class="line">从研发到上式、最低花费也要几万美元、高的话、可能在几千万到数亿美元、还要失败的可能,</span><br><span class="line">若设计的芯片最终只制造几千片、那还是FPGA的成本较低</span><br><span class="line"></span><br><span class="line"><span class="title">实际上:</span> 到底采用FPGA这样的可编程通用硬件、还是ASIC这样的专用芯片, 核心决定因素还是成本(不止是单个芯片的制造成本、还包括总体拥有成本)</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>FPGA</code> 本质上是一个可以通过编程来控制硬件电路的芯片、通过<code>LUT</code>这样的存储设备来代替硬连线的电路、有了可编程逻辑门、然后把LUT和寄存器放在一起、变成一个更复杂的电路<code>CLB</code>, 单号通过可编程布线中的开关、设计成芯片、<code>FPGA</code>常用来进行芯片的设计和验证、也可直接当成专用芯片、替代CPU或者GPU<br>相比<code>FPGA</code>, <code>ASIC</code>设计出来的芯片针对特殊场景、研发成本高、制造成本和能耗较低、针对大量需求、适合<code>ASIC</code></p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/12/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/12/">12</a><span class="page-number current">13</span><a class="page-number" href="/page/14/">14</a><span class="space">&hellip;</span><a class="page-number" href="/page/17/">17</a><a class="extend next" rel="next" href="/page/14/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">niuniu</p>
  <div class="site-description" itemprop="description">多数是学习笔记、偶尔发发感慨、给生活添加些许乐趣</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">162</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
        <span class="site-state-item-count">16</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">16</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">niuniu</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
