---
title: 幻读是什么,-幻读有什么问题
date: 2020-03-20
categories:
  - MySQL
tags:
  - MySQL
---

> Innodb默认事务隔离级别是可重复读. 接下来的场景设定在可重复读隔离级别(特殊说明除外)

一、幻读是什么 ?
![假设只在id=5这行加锁.png](https://upload-images.jianshu.io/upload_images/14027542-a05959ed4d3c5fed.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

1. 在Q1只返回id=5这一行
2. 在T2时刻、session B把id=0 这行的d值改为5、T3时刻Q2查询出来 id=5 和 id=0 这两行
3. T4时刻、session C 又插入一行 (1,1,5), 因此T5时刻、查出 id=0, 1, 5三行.
Q3读到id=1 这一行的现象被称为`幻读`.

`幻读`: 一个事务在前后两次查询同一个范围的时候、后一次查询看到了前一次查询未看到的行. 两点说明: 
1. 在可重复读隔离级别下、普通查询是快照读、不会看到别的事务插入数据, 所以、只会在当前读下才会出现.
2. 幻读 仅指新插入的行被读到、修改后满足条件、而被读取到、不能称为`幻读`.


二、幻读有什么问题 ?
1. 首先是语义上的. 前一次查询已经声明要把d=5的行加锁、不许别的事务进行读写操作, 而幻读却破坏了这个语义.
2. 是数据一致性的问题. 锁的设计是为了保证数据的一致性. 这个一致性、不止是数据库内部数据状态此刻的一致性、还包含了数据和日志在逻辑上的一致性.

三、如何解决幻读?
产生幻读的原因是: 行锁只能锁住行、但是新插入记录这个动作、要更新的是记录之间的间隙、为了解决幻读、就引入了间隙锁(Gap Lock).
跟行锁产生冲突的是、另外一个行锁. 跟间隙锁存在冲突关系的是: 往间隙中插入一个记录这个操作. 间隙锁之间不存在冲突关系.
![两种行锁之间的冲突关系.png](https://upload-images.jianshu.io/upload_images/14027542-e275608aeb25fad2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

间隙锁和行锁合称 next-key lock, 每个next-key lock是前开后闭的区间. 即: 若表t初始化后、若用select * from t for update. 将整个记录锁起来、就会形成7个next-key lock, 分别是 (-∞,0]、(0,5]、(5,10]、(10,15]、(15,20]、(20, 25]、(25, +supremum].
![表t主键索引上的行锁和间隙锁.png](https://upload-images.jianshu.io/upload_images/14027542-84514755a22c141e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

但: 间隙锁的引入会降低db的并发度.

如果事务隔离级别是: RC(Read Committed)就不会有间隙锁了.
那线上业务该如何选择隔离级别呢 ?
1. 若读提交隔离级别够用、业务不需要可重复读的保证、这样考虑读提交下操作数据的锁范围更小(没有间隙锁), 这个选择是合理的.
2. 业务逻辑使用读提交、逻辑备份时、mysqldump为什么把备份线程设置为 可重复读呢 ?
