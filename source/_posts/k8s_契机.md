---
title: k8s出现的契机
date: 2020-03-26 17:42:25
tags: Kubernetes
categories: Kubernetes
---



#### 背景

以 `Colud Foundry` 为代表的开源PaaS项目、在2013年已经度过了最艰难的概念普及和用户教育阶段、吸引了包括京东、华为、百度、IBM等一大批国内外技术厂商, 开启了以开源PaaS为核心构建平台服务能力的变革、而此时 Docker 项目却意外的出现了. Dot Cloud 公司开源了Docker项目. 

PaaS平台被接纳的主要原因是提供了 `应用托管能力`, `Cloud Foundry` 最核心的组件是应用的打包和分发机制.  `cf push` 基本上等同于将应用的可执行文件和启动脚本打进一个压缩包内, 上传到cf的存储中. 接着, 会通过调度器选择一个可运行该应用的虚拟机、通知虚拟机上的agent把应用压缩包下载启动.

若需要启动很多个来自不同用户的应用呢 ? 

cf 会调用操作系统的 `Cgroups` 和 `Namespace` 机制来为每一个应用单独创建一个称为 `沙盒`的隔离环境、分别在隔离环境中运行. 

`Docker` 实际上跟`Cloud Foundry` 基本类似、大部分功能和实现原理都一样. 然而、正是这一点点差异 造就了`Docker`, 它在几个月内快速崛起.

`Docker image` 就是这一点点的差异.  PaaS之所以能帮助大规模用户部署应用到集群里、是因为提供了打包的功能、偏偏也就是`打包`这个功能、却成了一个软肋. 因为一旦用上PaaS、就必须为每种语言、每种框架甚至每个版本都得维护一个包, 比较麻烦的是本地运行很好的项目、需要修改很多东西和配置才能在PaaS里运行. 为了 `cf push` 这个一键部署的工作、`打包`这个前置工作特别麻烦

`Docker image` 从根本上解决了这个问题. 所谓 Docker 镜像, 其实就是一个压缩包. 大多数Docker 镜像包含一个完整的操作系统和所有文件、目录, 这个压缩包的环境、与本地完全一致. 那么、如果本地环境是 CentOS 7.2, 使用CentOS 7.2 的ISO做一个压缩包、再把应用可执行文件也压缩进去, 就可以得到一个与本地完全一致的环境了. 它包含了应用运行的所有依赖.

这就是 Docker 镜像的精髓.

`docker build "image name"` 就可以制作成一个压缩包.

`docker run "image name"` 就是用Docker创建一个`沙盒`来解压镜像、然后在其中运行应用.

`docker run` 创建的`沙盒`, 也是使用 `Cgroups` 和 `namespace`创建的隔离环境.



#### Docker崛起

Docker解决了应用打包和发布的问题, 且将一个存后端的技术概念通过友好的设计和封装、交给了广大的开发者. 得以迅速受到青睐.  一个以容器为中心的全新云计算市场、即将呼之欲出, 此时 dotCloud 公司、却突然改名 `Docker`, 意味着, 任何公司都不能在商业活动中再使用这个词及鲸鱼的logo. 14年, 又发布了 `Swarm` 项目. 兜兜转转, Docker 公司还是回到了`如何让开发者把应用部署到我的项目`这个主题上. 

此时, PaaS 已经变成了一套以 Docker 容器为技术核心、以Docker镜像为打包标准的、全新的容器化思路. 

这、正是 Docker 项目从开始悉心运作`容器化`概念和努力经营 Docker 生态系统的目的. 而 `Swarm` 项目、正是承载Docker接下来所有这些努力的关键.

综合来说、Docker的崛起有3个因素:

1. Docker镜像通过技术手段解决了 PaaS平台的根本性问题.
2. Docker 容器和开发者之间与生俱来的密切关系
3. PaaS概念已深入人心的完美契机.

 

#### 群雄并起









 



