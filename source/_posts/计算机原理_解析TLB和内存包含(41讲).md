---
title: 解析TLB和内存包含(41讲)
date: 2020-03-20
categories:
  - 计算机原理
tags:
  - 计算机原理
---
> 机器指令里的地址都是虚拟内存地址、程序里的每一个进程、都有属于自己的内存地址空间
可通过地址转换得到最终的实际物理地址. 指令都放在内存里、数据页都在内存、`地址转换`是一个高频动作、必须保证性能问题

#### 加速地址转换TLB
```
从虚拟地址到物理地址的转换、可通过页表来处理、为节约存储空间、使用多级页表
内存访问比Cache慢很多、简单的地址转换按照多级页表的设计会有很性能损失、怎么办呢? -- 加个缓存试试呢 ?

程序需要的指令、都顺序放在虚拟内存里、执行的指令也是一条条顺序执行的
即:对于指令地址的访问、存在局部性(空间局部性和时间局部性)、需要的数据也是一样的
连续执行5条指令、因为地址都是连续的、所以这5条指令通常在同一个虚拟页里
因此、连续5次的内存地址转换、其实都来自于同一个虚拟页号、转换的结果自然是同一个物理页号、
就可以将之前的内存地址转换缓存下来、不需要反复访问内存来进行内存地址的转换

于是、专门在CPU里放了一块缓存芯片、称为`TLB`(Translation-Lookaside Buffer)地址变换高速缓存
存放已进行转换过的结果、同样的虚拟地址需进行地址转换的时候、可直接在TLB里查询结果、无需多次访问内存来完成转换

TLB和CPU的高速缓存类似、可分为指令的TLB和数据的TLB、即: ITLB
 和 DTLB、也可分级、变成L1、L2这样多层的TLB

需要脏标记这样的标记位来实现`写回`这样缓存管理策略、也和高速缓存很类似

为了性能、整个内存转换过程也由硬件来执行、CPU芯片里、封装了内存管理单元MMU(Memory Management Unit)来完成地址转换
```

#### 安全性和内存保护
```
虽然现代操作系统和CPU、有各种权限管控、通过虚拟内存和物理内存的区分、隔离了各个进程
但: 无论CPU这样的硬件还是操作系统这样的软件、都很复杂、难免会被黑客找到各种漏洞

计算机最底层的安全保护机制称为内存保护、如`可执行空间保护`和`地址空间布局随机化`等
```

#### 可执行空间保护
```
对一个进程使用的内存、只把指令部分设置成`可执行`的、其它、如数据部分、不给予执行权限
因为无论指令还是数据、在CPU看来、都是二进制的数据、直接将数据部分拿给CPU、数据解码后、也是合理的指令、即可执行的

此时黑客们就想到了在程序的数据区、放入一些要执行的指令编码后的数据、让CPU当成指令去加载、
CPU就能执行想执行的指令了、对内存空间的执行权限进行控制、就使得CPU只能执行指令区的代码、
对数据区的内容、即时找到了其它漏洞想装成指令被执行也会因为没权限而被阻挡掉
eg. php进行web开发时、通常会禁用php执行eval函数的执行权限
sql注入攻击
```

#### 地址空间布局随机化
```
内存层面的安全保护核心策略、是在可能有漏洞的情况下进行安全预防、可执行空间保护就是很好的例子、
但内存层面的漏洞还存在其它的可能性:
eg. 其它的人、进程和程序修改调特定进程的指令、数据、让当前进程执行特定的指令和数据、造成破坏

原先、进程的内存布局空间是固定的、任何第三方很容易知道指令在哪里、程序桟、堆、数据又在哪里
为人文破坏创造了很大的便利、`地址空间布局随机化`就是让位置不固定、让内存空间随机分配这些进程里
不同部分所在的额内存空间地址、让破坏者猜不出来、减小破坏性
eg. 密码登录
```
