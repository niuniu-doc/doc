---
title: CPU发回顾
date: 2020-03-20
categories:
  - 计算机原理
tags:
  - 计算机原理
---
```
指令周期: Fetch -> Decode -> Execute

CPU周期: 从内存取出一条指令的最短时间(一个指令周期至少需要2个CPU周期)

通过D触发器实现存储功能
通过时钟信号实现计数器

一个时钟周期内确保完成一条最复杂的CPU指令 -> 单指令周期处理器
译码器 -> 从输入的多个位的信号中、根据一定的开关和电路组合、选择出自己想要的信号
优化1: CPU流水线设计(保障一个最复杂的流水线级在一个时钟周期内完成即可)
       不能优化单条指令执行延时、可以提高CPU的吞吐率(可同时并行多条指令)
       
       缺点: 流水线深度增加带来性能成本、每级流水线的输出需放到流水线寄存器、然后在下一个时钟周期、交给下一个流水线级处理、每增加一级就要多一次写入流水线寄存器的操作(20ps)
       为了保证指令的响应时间这个指标、只有提升时钟周期、电路数量和晶体管数量都会增加、功耗变大
       
       挑战: 冒险和分支预测
 
优化2: 结构冒险 -> 增加资源(eg. 数据内存和指令内存分开, 现代CPU只将CPU内部的缟素缓存分成指令缓存和数据缓存)

优化3: 数据冒险 -> 流水线停顿(插入NOP操作), 最差会退化成单指令周期CPU
优化4: 数据冒险 -> 操作数前推(操作数转发、节省了写入写入寄存器、从寄存器读出的时间)
优化5: 乱序执行 -> 将指令发送到保留站 -> 提交到不同的FU -> 重排缓存区重排(cpu按照取指顺序、对指令结果重排, 只有排在前边的都完成、才提交指令、完成指令运算) -> 指令提交
       提高了CPU的吞吐量
优化6: 分支预测(缩短分支延迟、动态分支预测、静态分支预测)
优化7: 超标量(多发射, 让cpi>1, 并行取指、译码 -> 需要增加电路元件)
优化8: 超线程: 在一个CPU内部、有双份PC寄存器、指令寄存器、条件码寄存器、同时维护两个并行指令的状态(指令译码器、ALU都只有单份)
优化9: SIMD(单指令多数据流):一次加载多个整数、然后使用多个FU并行计算(MMX)
```
