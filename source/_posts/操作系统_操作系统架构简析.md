---
title: 操作系统架构简析
date: 2020-03-20
categories:
  - 操作系统
tags:
  - 操作系统
---
`CPU` 最核心的组件, 中央处理器 `Central Processing Unit`

`Bus` 总线, CPU 和 其它设备连接的桥梁、其实就是主板上密密麻麻的集成电路

`内存` 最重要的设备、与CPU一样、是完成计算任务的核心组件

> cpu 包含 运算单元、数据单元 和 控制单元
>
> 运算单元: 负责计算, eg. 加法、移位等. 但不知道结果存放在哪里 
>
> ​                  若每次通过总线到内存去拿、速率很低、所以有了数据单元
>
> 数据单元: 包括CPU内部的缓存和寄存器组、空间小、速度高、可暂时存放数据和运算结果
>
> 控制单元: 同一指挥中心、获取指令 & 执行指令, 会指导运算单元取出数据单元中的某几个数据、计算出结果、然后存放在数据单元的某个地方



CPU这么执行程序, 操作数据, 并将结果写回内存的呢 ？

```
 CPU的控制单元里, 有一个指令指针寄存器、存放的是下一条指针的地址, 控制单元会不断将代码段的指令拿进来、写入指令寄存器
 
 当前指令分为: 做什么操作 ？ 操作哪些数据？
 数据单元根据数据地址、从数据段读到数据寄存器、然后参与运算、运算结果会暂存在数据单元的数据寄存器、最终会有指令将数据写回内存中的数据段
 
 CPU有两个寄存器, 专门保存当前处理的代码段的起始地址和数据段的起始地址.
 里边是哪个进程就执行哪个进程的指令、等切换成另一进程就会执行另一进程的额指令、这个过程叫 进程切换 Process Switch
 
```

> CPU 和 内存进行数据交换、靠的是总线 `Bus`, 分为 `地址总线` 和 `数据总线`
>
> `地址总线`的位数、决定可寻址范围, eg 只有两位、那CPU只认 `00` `01` `10` `11` 四个位置
>
> `数据总线` 的位数、决定一次可以拿多少个数据进来、
>
> eg. 只有两位、CPU一次只能拿2位数、要想拿8位就需要4次、位数越多、一次拿的数据就越多、访问速度也越快



**8086 系统架构**

8个16位通用寄存器 `AX` `BX` `CX` `DX` `SP` `BP` `SI` `DI`主要用于计算过程中暂存数据 (数据单元)

`IP` 指令指针寄存器`Instruction Pointer Register` 指向代码段下一条指令的位置, CPU根据它从内存的代码段加载指令到CPU的指令队列中、交给运算单元去执行

`段寄存器`：

 `CS` 代码段寄存器, 保存代码在内存中的位置 `Code Segment Registeer`

`DS` 数据段寄存器, 保存数据在内存中的位置 `Data Segment Register`

`SS` 桟寄存器 `Stack Register` 程序运行中的一个特殊结构、存取只能从一端进行 

`ES` 



> 若运算中需要加载内存中的数据、需要通过`DS`找到内存中的数据, 加载到通用寄存器中该如何加载？
>
> 对于一个段、有一个起始的地址、而段内的具体位置、称为偏移量 Offset



在`CS`和 `DS`中都存放着一个段的起始地址、代码段的偏移量在`IP寄存器`中、数据段的偏移量通常在 `通用寄存器`中

那么问题来了:

`CS`和`DS`都是16位的、即: 起始地址都是16位的、

IP寄存器和通用寄存器都是16位的、即: 偏移量也是16位的

但: 8086 的地址总线是20位、怎么做? 

```
起始地址*16 + 偏移量, 即: 把CS和DS中的值、左移4位 + 16位的偏移量 得到20位的数据地址
```

>  so. 无论真正的内存是多大、对于只有20位地址总线的8086来说、能识别出的地址只有 2^20 = 1M
>
> 偏移量是16位、段大小最大为 2^16 = 64k



#### 32位处理器

在32位处理器中、有32根地址总线、可以访问 2^32=4G 的内存

那如何去兼容原有8086架构呢？

1. 通用寄存器扩展、将8个16位的扩展到8个32位的、保留8位和16位的使用方式

![image.png](https://upload-images.jianshu.io/upload_images/14027542-6275d5210fda1f81.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)


改动较大的是 段寄存器(Segment Register)

`CS`、`DS`、`SS`、`ES` 还是16位, 但不再是段的起始地址、段的起始地址放在内存、该内存是一个保存了段描述符的表格、段寄存器中保存的是在表格中的哪一项、称为`选择子(Selector)`



这种模式灵活度比较高、将来也可以一直兼容、前边的设计就不够灵活

前一种模式、称为 `实模式` `Real Pattern`, 后一种模式称为`保护模式` `Protected Pattern`

![image.png](https://upload-images.jianshu.io/upload_images/14027542-5599d15b659b6c48.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)




参考:

https://time.geekbang.org/column/article/89417
