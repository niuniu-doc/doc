---
title: RISC和CISC
date: 2020-03-20
categories:
  - 计算机原理
tags:
  - 计算机原理
---
> `CISC`: `Complex Insturction Set Computing `, 即: 复杂指令集
>
> `RISC`: `Reduced Instruction Set Computing`, 即: 精简指令集



```
早期、所有的CPU都是 CISC、并无 CISC 和 RISC 之分 
CPU指令集的设计、需要考虑硬件限制、为了性能考虑、很多功能直接通过硬件电路完成、为了减少内存、指令的长度也是可变的, 常用指令的长度短一些、不常用指令长度可以长一些

随历史发展、计算机性能和存储都在发展、当时 大卫*帕特森教授发现: 实际在CPU运行的程序里、80%都是在使用 20% 的简单指令、提出 RISC的理念

RISC的CPU想法其实很直观、既然80%的时间都在使用20%的简单指令、那只使用20%的简单指令呢？ - 因为指令数量很多、计算机科学家在软硬件两方面都受到了很大的挑战

在硬件层面、想支持更多的复杂指令、CPU里的电路就要越复杂、在散热和功耗上也就会带来更大的挑战、
在软件层面、支持更多的复杂指令、编译器的优化就更难

于是在RISC架构里、CPU选择将指令精简到20%的简单指令、而原先的复杂指令 则用简单指令组合起来实现、让软件实现硬件的功能、这样CPU的硬件设计就更简单了、性能提升也会变的容易

RISC的CPU里完成指令的电路变简单了、就腾出了更多空间、这个空间、常被拿来放通用寄存器、因为RISC完成同样的功能、执行的指令数要比CISC多、所以、若需要反复从内存读取指令或者数据到寄存器、很多时间就会花在访问内存上、于是, RISC架构的CPU往往有更多的通用寄存器、

除了寄存器这样的存储空间、RISC的CPU也可以把更多的晶体管、用来实现更好的分支预测等相关功能、进一步提升CPU的实际利用率

`CPU执行时间` = `指令数` * `CPI` * `Clock Cycle Time`

CISC的架构其实就是通过优化指令数、来减少CPU的执行时间、而RISC的架构、其实是在优化CPI
指令比较简单、需要的时钟周期就很少

```



#### 微指令架构

```
在微指令架构的CPU里、编译器编译出来的机器码和汇编代码没发生变化、但: 在指令译码阶段、指令译码器翻译出来的、不再是某一条CPU指令、译码器会把一条机器码、翻译成好几条微指令、这一条条的微指令就变成了固定长度的RISC风格的了

这些RISC风格的微指令、会被放在一个微指令缓冲区里、然后再从缓冲区里边、分发给后边的超标量、且乱序执行的流水线架构里(精简指令)、在这个架构里、指令译码器相当于变成了`适配器`, 填平； CISC和RISC之间的指令差异

但: 这样一个可以把CISC的指令译码成RISC指令的指令译码器、比原来的译码器要复杂、就意味着更复杂的电路和更长的译码时间, 本来以为可以通过RISC提升的性能、又有一部分浪费在了指令译码上、怎么解决呢?

由于80%运行的代码、只包含20%的常用指令、这个很强的局部性、可以使用缓存来解决.
Intel在CPU里加了一层 L0 Cache、这个Cache保存的就是指令译码器把CISC的指令翻译RISC的微指令的结果、于是大部分情况、CPU可以从Cache拿到译码结果、而不用实际译码, 不仅优化了性能、因为译码器的开关动作变少了、还减少了功耗

由于Intel本身在CPU层上做过大量优化: 分支预测、乱序执行等、X86的CPU始终在功耗上还是要超过RISC架构的ARM、所以最终在智能手机崛起替代PC的时代、落在了ARM后面
```



#### CPU的现在和未来

```
现在、CISC和RISC架构的分界已经不明显了、Intel和AMD的CPU也都是采用译码成RISC风格的微指令来运行、而ARM的芯片、一条指令通用需要多个时钟周期、有乱序执行和多发射

未来的CPU、多半会像Linux一样、逐渐成为一个业界的主流选择、若想打造一个属于自己的CPU、可以关注下 RISC-V开源项目的发展

```
