---
title: 多发射和VLIW
date: 2020-03-20
categories:
  - 计算机原理
tags:
  - 计算机原理
---
> `程序的CPU执行时间`=`指令数` * `CPI` * `Clock Cycle Time`(时钟周期)

`CPI`: 倒数是`IPC`,即: 一个时钟周期内能够执行的指令数、代表了CPU的吞吐率

那么: CPU的吞吐率能达到多少呢 ? 

> 最佳情况下、也只能达到1, 即使达到了指令层面的乱序执行、CPU一个周期、仍然只能取一条指令、说明指令优化做的多好、一个时钟周期也只能完成一条指令、而现在的CPU一般能达到2、为什么呢 ?



#### 多发射与超标量: 同一时间执行的两条命令

```
在指令乱序执行的过程中、取值IF 和 指令译码ID 部分并不是并行的、那么 可不可以呢 ?
1. 将取指令和指令译码、也通过增加硬件的方式、一次从内存里取出多条指令、然后并行的分发给多个并行的指令译码器、进行译码、然后交给不同的FU(功能单元)去处理、这样一个时钟周期可完成的指令就大于1 、即: IPC大于1

这种CPU设计叫 多发射(Mulitple issue) 和 超标量(Superscalar)

在超标量的CPU里边、有很多条并行的流水线、而不是只有一条流水线、
`超标量`这个词是说, 本来我们在一个时钟周期里、只能执行一个标量Scalar运算、在多发射的情况下、可以超过这个限制、同时进行多次运算

```



#### Intel的失败之作: 安腾的超长指令设计

```
无论是乱序执行、还是超标量技术、在实际的硬件层面、都需要解决依赖冲突(冒险)问题、所以、实施会比较复杂
CPU需要在指令执行之前、判断指令是否有依赖关系、若有, 则不能分发到不同的执行阶段、
所以: 超标量CPU发射、又被称为动态多发射处理器
对于 依赖关系的检测、会使得CPU电路变的更加复杂

于是: 科学家有一个大胆的想法: 将分析和解决依赖关系的事情、放到软件里
`超长指令设计`: VLIW(Very Long Insturction Word)、想通过编译器来优化CPI
编译器在汇编完成之后、也可以知道前后数据的依赖、可以让编译器把没有依赖关系的代码位置进行交换、然后把多条连续的指令打成一个指令包、安腾的CPU就是把3条指令打成一个指令包, 如下图所示:
CPU在运行的时候、就不再是取一条指令、而是取一个指令包、然后译码解析整个指令包、解析出3条指令并行运行
2.流水线停顿、也是编译器来做了、除了停下整个处理器流水线、CPU不能在某个周期停顿一下、等待前边依赖的操作完成、编译器需要在适当的位置插入NOP操作、直接在编译出来的机器码里、把流水线停顿设计完成

```
![image.png](https://upload-images.jianshu.io/upload_images/14027542-f665e77afa662d94.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

##### 为什么失败呢
```
1. 最重要的原因是'向前兼容'
   安腾处理器的指令集和X86不同、无法兼容、需要重新编译才可以
2. VLIW架构决定了、若安腾需要提升并行度、就需要增加一个指令包的指令数量、eg. 3个 -> 6个、
   而一旦这么做了、同样是VLIW架构、同样指令集的安腾CPU也需要重新编译、甚至需要重写编译器、才能在原来的CPU上继续运行程序
   
   所以、它既不向前兼容、又很难向后兼容、就比较容易失败
```
 
